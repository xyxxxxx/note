

实际上**存储器系统（memory system）**是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保存着最常用的数据；靠近CPU的小的、快速的**高速缓存存储器（cache memory）**作为部分存储在相对慢速的主存储器（main memory）中数据和指令的缓冲区域；主存缓存存储在容量较大的、慢速磁盘上的数据；磁盘又常常作为存储在通过网络连接的其它机器的磁盘或磁带上的数据的缓冲区域。

作为一个程序员，你需要理解存储器层次结构，因为它对应用程序的性能有着巨大的影响。如果你的程序需要的数据存储在CPU寄存器中，那么在指令的执行期间，在0个周期内就能访问到它们；如果存储在高速缓存中，需要4~75个周期；如果存储在主存中，需要上百个周期；而如果存储在磁盘上，则需要大约几千万个周期！因此编写应用程序时，应尽量使数据项存储在层次结构较高的地方，在那里CPU可以更快地访问它们。

程序具有一个称为**局部性（locality）**的基本属性。具有良好局部性的程序倾向于一次又一次地访问相同的数据项集合，或是倾向于访问临近的数据项集合。具有良好局部性的程序比局部性差的程序更多地倾向于从存储器层次结构中较高层次处访问数据项，因此运行得更快。例如在Core i7系统，不同的矩阵乘法核心程序执行相同数量的算数操作，但是因为不同程度的局部性，运行时间可以相差40倍！

# 存储技术

## 随机访问存储器

**随机访问存储器（RAM，Random-Access Memory）**分为两类：静态的和动态的。静态RAM（SRAM）比动态RAM（DRAM）更快，但也贵得多。<u>SRAM用来作为高速缓存存储器</u>，既可以在CPU芯片上，也可以在片下；DRAM用来作为主存以及图形系统的帧缓冲区。典型地，一个桌面系统的SRAM不会超过几兆字节，但是DRAM却有几千兆字节。

SRAM和DRAM的介绍略。

### 传统的DRAM

DRAM芯片中的所有单元（位）被分为 $d$ 个**超单元（supercell）**，每个超单元都由 $w$ 个DRAM单元组成。一个 $d\times w$ 的DRAM总共存储了 $dw$ 位信息。超单元被组织为一个 $r$ 行 $c$ 列的矩阵，这里 $rc=d$。每个超单元有形如 $(i,j)$ 的地址，其中 $i$ 表示行， $j$ 表示列。

例如，下图展示了一个16×8的DRAM芯片的组织，有 $d=16$ 个超单元，每个超单元有 $w=8$ 个单元（位）， $r=4, c=4$。带阴影的方框表示地址(2, 1)处的超单元。信息通过称为**引脚（pin）**的外部连接器流入和流出芯片。每个引脚携带1位的信号。下图给出了两组引脚：8个`data`引脚，它们能传送一个字节到芯片或从芯片传出一个字节；2个`addr`引脚，它们携带2位的行和列超单元地址。其它携带控制信息的引脚没有显示出来。

图6-3

每个DRAM芯片被连接到称为**内存控制器（memory controller）**的电路，这个电路可以<u>一次传送 $w$ 位到*每个*DRAM芯片或一次从*每个*DRAM芯片传出 $w$ 位</u>。为了读出超单元 $(i,j)$ 的内容，内存控制器将行地址 $i$ 发送到DRAM，然后发送列地址 $j$。DRAM把超单元 $(i,j)$ 的内容发回控制器作为响应。行地址 $i$ 称为**RAS（Row Access Strobe, 行访问选通脉冲）**请求，列地址 $j$ 称为**CAS（Column Access Strobe, 列访问选通脉冲）**请求。注意RAS和CAS请求共享相同的DRAM地址引脚。

例如，要从上图中16×8的DRAM读出超单元(2, 1)，内存控制器发送行地址2，如下图a所示，DRAM的响应是将行2的整个内容都复制到一个内部行缓冲区。然后，内存控制器发送列地址1，如下图b所示，DRAM的响应是从行缓冲区复制出超单元(2, 1)中的8位，并把它们发送到内存控制器。

图6-4

电路设计者将DRAM组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。例如，如果示例的128位DRAM被组织成一个16个超单元的线性数组，地址为0~15，那么芯片会需要4个地址引脚而不是2个。二维阵列组织节约了地址引脚的数量，但增加了发送地址的次数，这增加了访问时间。

### 内存模块

DRAM芯片封装在**内存模块（memory module）**中，它插在主板的扩展槽上。Core i7系统使用240个引脚的**双列直插内存模块（Dual Inline Memory Module, DIMM）**，它以64位为块传送数据到内存控制器和从内存控制器传出数据。

下图展示了一个内存模块的基本思想。示例模块用8个8M的DRAM芯片，总共存储64MB，这8个芯片编号为0~7。每个**超单元（supercell）**存储主存的一个字节，而用地址为 $(i, j)$ 的8个超单元来表示主存中字节地址A处的64位字。下图的示例中，DRAM 0存储第一个（低位）字节，DRAM 1存储下一个字节，以此类推。

图6-5

要取出内存地址A处的一个64位字，<u>内存控制器将A转换为一个超单元地址 $(i,j)$，并将它发送到内存模块，然后内存模块再将 $i$ 和 $j$ 广播到每个DRAM</u>。作为响应，<u>每个DRAM输出它的 $(i,j)$ 超单元的8位内容，内存模块的电路收集这些输出，并把它们合并成一个64位字，再返回给内存控制器</u>。

通过<u>将多个内存模块连接到内存控制器</u>，能够聚合成主存。在这种情况中，当控制器收到一个地址A时，控制器选择包含A的模块 $k$，将A转换称它的 $(i,j)$ 形式，并将 $(i,j)$ 发送到模块 $k$。

### 非易失性存储器

如果断电，DRAM和SRAM会丢失它们的信息，从这个意义上说，它们是**易失的（volatile）**；**非易失性存储器（nonvolatile memory）**即使在关电后，仍然保存着它们的信息。现在有很多种非易失性存储器。

由于历史原因，虽然ROM中有的类型既可以读又可以写，但是它们整体上都被称为**只读存储器（Read-Only Memory, ROM）**。ROM以它们能够被重编程（写）的次数和对它们进行重编程（写）的机制来区分。

**PROM（Programmable ROM, 可编程ROM）**只能被编程一次。PROM的每个存储器单元有一种熔丝（fuse），只能用高电流熔断一次。

**EPROM（Erasable PROM, 可擦除可编程ROM）**有一个透明的石英窗口，允许光到达存储单元；紫外线光照射过窗口，EPROM单元就被清除为0。对EPROM编程是通过使用一种把1写入EPROM的特殊设备来完成的。EPROM能够被擦除和重编程的次数的数量级可以达到1000次。

**EEPROM（Electrically Erasable PROM, 电子可擦除可编程ROM）**类似于EPROM，但是它不需要一个物理上独立的编程设备，因此可以直接在印制电路卡上编程。EEPROM能够被编程的次数的数量级可以达到 $10^5$ 次。

**闪存（flash memory）**是一类非易失性存储器，基于EEPROM，它已经成为了一种重要的存储技术。闪存无处不在，为大量的电子设备提供快速而持久的非易失性存储。在后面我们会仔细研究一种新型的基于闪存的磁盘驱动器，称为**固态硬盘（Solid State Disk, SSD）**，它能提供相对于传统旋转磁盘的一种更快速、更强健和更低能耗的选择。

存储在ROM设备中的程序通常被称为**固件（firmware）**。当一个计算机系统通电以后，它会运行存储在ROM中的固件。一些系统在固件中提供了少量基本的输入输出函数，例如主板的BIOS（基本输入输出系统）例程。复杂的设备，像图形卡和磁盘驱动控制器，也依赖固件翻译来自CPU的I/O请求。

### 访问主存

数据流通过称为**总线（bus）**的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为**总线事务（bus transaction）**。**读事务（read transaction）**从主存传送数据到CPU，**写事务(write transaction)**从CPU传送数据到主存。

<u>总线是一组并行的导线，能够携带地址、数据和控制信号</u>。两个以上的设备可以共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。

下图展示了一个示例计算机系统的配置。主要部件是CPU芯片、称为**I/O桥接器（I/O bridge）**的芯片组（其中包括内存控制器），以及组成主存的DRAM内存模块。这些部件由一对总线连接起来，其中一条总线是**系统总线（system bus）**，它连接CPU和I/O桥接器，另一条总线是**内存总线（memory bus）**，它连接I/O桥接器和主存。I/O桥接器将系统总线的电子信号翻译成内存总线的电子信号。

考虑当CPU执行一个如下加载操作时会发生什么

```
movq A, %rax
```

这里，地址A的内容被加载到寄存器`%rax`中。CPU芯片上称为**总线接口（bus interface）**的电路在总线上发起读事务。读事务由三个步骤组成：首先，CPU将地址A放到系统总线上，I/O桥将信号传递到内存总线（如图a）；接下来，主存感觉到内存总线上的地址信号，从内存总线读地址，从DRAM取出数据字，并将数据写到内存总线（图b）；最后，CPU感觉到系统总线上的数据，从总线上读数据，并将数据复制到寄存器`%rax`中（图c）。

图6-7

反过来，当CPU执行一个像下面这样的存储操作时

```
movq %rax, A
```

这里，寄存器`%rax`的内容被写到地址A，CPU发起写事务。同样有三个基本步骤：首先CPU将地址放到系统总线上，内存从内存总线读出地址，并等待数据到达（如图a）；接下来，CPU将`%rax`中的数据字复制到系统总线（图b）；最后，主存从内存总线读出数据字，并且将这些位存储到DRAM中（图c）。

### 磁盘存储

磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆（吉）字节，而基于RAM的存储器只能有几百到几千兆字节。不过，从磁盘上读信息的时间为毫秒级，比从DRAM读慢了10万倍，比从SRAM读慢了100万倍。

#### 磁盘构造

磁盘是由盘片（platter）构成的。每个盘片有两面或者称为表面（surface），表面覆盖着磁性记录材料。盘片中央有一个可以旋转的主轴（spindle），它使得盘片以固定的旋转速率（rotational rate）旋转，通常是5400~15000转每分钟（Revolution Per Minute, RPM）。磁盘通常包含一个或多个这样的盘片，并封装在一个密封的容器内。

如图a展示了一个典型的磁盘表面的结构。每个表面是由一组称为磁道（track）的同心圆组成的。每个磁道被划分为一组扇区（sector）。每个扇区包含相等数量的数据位（通常是512字节），这些数据编码在扇区上的磁性材料中。扇区之间由一些间隙（gap）分隔开，这些间隙中不存储数据位，而存储用来标识扇区的格式化位。

<u>磁盘由一个或多个叠放在一起的盘片组成，它们被封装在一个密封的包装里</u>，如图b所示。整个装置通常被称为**磁盘驱动器（disk drive）**，我们通常简称为磁盘（disk）。有时我们会称磁盘为旋转磁盘（rotating disk），以使之区别于基于闪存的固态硬盘（SSD），SSD没有移动部分。

磁盘制造商通常用术语柱面（cylinder）来描述多个盘片驱动器的构造，这里柱面是所有盘片表面上到主轴中心的距离相等的集合。例如如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面 $k$ 就是6个磁道 $k$ 的集合。

图6-9

#### 磁盘容量

一个磁盘上可以记录的最大位数称为它的最大容量，或者简称为容量。磁盘容量由以下技术因素决定：

+ 记录密度（recording density）：磁道一英寸的段中可以放入的位数
+ 磁道密度（track density）：从盘片中心出发半径上一英寸的段内可以有的磁道数
+ 面密度（areal density）：记录密度和磁道密度的乘积

下面的公式给出了一个磁盘的容量：
$$
磁盘容量=\frac{字节数}{扇区}\times\frac{平均扇区数}{磁道}\times\frac{磁道数}{表面}\times\frac{表面数}{盘面}\times\frac{盘面数}{磁盘}
$$
例如对于一个磁盘，其有5个盘片，每个扇区512个字节，每条磁道平均300个扇区，每个面20000条磁道，那么这个磁盘的容量是
$$
磁盘容量=\frac{512字节}{扇区}\times\frac{300平均扇区}{磁道}\times\frac{20000磁道}{表面}\times\frac{2表面}{盘面}\times\frac{5盘面}{磁盘}\\
=30\ 720\ 000\ 000\ {\rm B}\\
=30.72\ {\rm GB}
$$

> 注意像k(kilo), M(Mega), G(Giga)和T(Tera)这样的前缀的含义依赖于上下文。对于DRAM和SRAM容量相关的计量单位，通常 ${\rm k}=2^{10},{\rm M}=2^{20},{\rm G}=2^{30},{\rm T}=2^{40}$ ；而对于像磁盘和网络这样的I/O设备容量相关的计量单位，通常 ${\rm k}=10^{3},{\rm M}=10^{6},{\rm G}=10^{9},{\rm T}=10^{12}$。速率和吞吐量常常也使用这些前缀。

#### 磁盘操作

磁盘用读/写头（read/write head）来读写存储在磁性表面的位，而读写头连接到一个传动臂（actuator arm）一端，如图a所示。通过沿着半径轴前后移动这个传动臂，驱动器可以将读/写头定位在盘面上的任何磁道上。这样的机械运动称为寻道（seek）。一旦读/写头定位到了期望的磁道上，那么<u>当磁道上的每个位通过它的下面时，读/写头可以感知到这个位的值（读该位），也可以修改这个位的值（写该位）</u>。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头，如图b所示。<u>读/写头垂直排列，一致行动</u>。在任何时刻，所有的读/写头都位于同一个柱面上。

图6-10

读/写头在磁盘表面高度大约0.1微米处的一层薄薄的气垫上飞翔，速度大约80km/h。在这样小的间隙里，盘面上一粒微小的灰尘都像一块巨石，因此磁盘总是密封包装的。

磁盘以扇区大小的块来读写数据。对扇区的访问时间（access time）有三个主要的部分：寻道时间、旋转时间和传送时间：

+ 寻道时间（seek time）：为了读取某个目标扇区的内容，传动臂首先将读/写头定位到包含目标扇区的磁道上。移动传动臂所需的时间称为寻道时间。寻道时间 $T_{seek}$ 依赖于读/写头之前的位置和传动臂在盘面上移动的速度。现代驱动器中平均寻道时间 $T_{avg\ seek}$ 时通过对几千次对随机扇区的寻道求平均值来测量的，通常为<u>3～9ms</u>。一次寻道的最大时间 $T_{max\ seek}$ 可以高达20ms。

+ 旋转时间（rotational latency）：一旦读/写头定位到了期望的磁道，驱动器等待目标扇区的第一个位旋转到读/写头下。这个步骤的性能依赖于当读/写头到达目标扇区时盘面的位置以及磁盘的旋转速度。在最坏的情况下，读/写头刚刚错过了目标扇区而不得不等待磁盘转一整圈。因此，最大旋转延迟是
  $$
  T_{max\ rotation}=\frac{1}{RPM}\times \frac{60s}{1\min}
  $$
  平均旋转时间 $T_{avg\ rotation}$ 是 $T_{max\ rotation}$ 的一半。

+ 传送时间（transfer time）：当目标扇区的第一个位位于读/写头下时，驱动器就可以开始读或者写该扇区的内容了。一个扇区的传送时间依赖于旋转速度和每条磁道的扇区数目。因此我们可以粗略地估计一个扇区以秒为单位的平均传送时间如下
  $$
  T_{a v g\ rotation}=\frac{1}{RPM}\times \frac{60s}{1\min}\times \frac{1}{平均扇区数/磁道}
  $$

我们可以估计访问一个磁盘扇区的内容的平均时间为平均寻道时间、平均旋转延迟和平均传送时间之和。例如考虑一个有如下参数的磁盘：

图

对于该磁盘，平均旋转延迟为
$$
T_{avg\ rotation}=1/2\times T_{max\ rotation}=1/2\times 60/7200\approx4{\rm ms}
$$
平均传送时间为
$$
T_{avg\ transfer}=60/7200\times 1/400\approx 0.02{\rm ms}
$$
整个访问时间为
$$
T_{access}=T_{avg\ seek}+T_{avg\ rotation}+T_{avg\ transfer}=9+4+0.02=13.02{\rm ms}
$$
这个例子说明了一些很重要的问题：

+ 访问一个磁盘扇区中512个字节的时间主要是寻道时间和旋转延迟。可以认为访问扇区中的第一个字节用了很长时间，但是访问剩余的字节几乎不用时间。
+ 寻道时间和旋转延迟大致相等，因此一个简单的估计磁盘访问时间的方法是将寻道时间乘2。
+ 对存储在SRAM中的一个64位字的访问时间大约是4ns，对DRAM的访问时间是60ns。因此从内存中读一个512字节扇区大小的块的时间对SRAM来说大约是256ns，对DRAM来说大约是4000ns。磁盘访问时间，大约10ms，是SRAM的大约40000倍，DRAM的大约2500倍。

#### 逻辑磁盘块

正如我们看到的，现代磁盘构造复杂，有多个盘面，每个盘面上有不同的记录区。为了对操作系统隐藏这样的复杂性，现代磁盘将它们的构造呈现为一个简单的视图，即扇区大小的逻辑块的长度为B的序列，编号为 $0,1,\cdots,B-1$。磁盘封装中有一个小的硬件/固件设备，称为磁盘控制器，维护着逻辑块号和实际（物理）磁盘扇区之间的映射关系。

当操作系统想要执行一个I/O操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个（盘面，磁道，扇区）的三元组，这个三元组唯一地标识了对应的

  

  

  

  

