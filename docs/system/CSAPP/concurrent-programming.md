到目前为止，我们主要将并发看作是一种操作系统内核用来运行多个应用程序的机制。但是并发不仅仅局限于内核，它也可以在应用程序中扮演重要角色。我们已经看到Linux信号处理程序如何允许应用响应异步事件，例如用户输入Ctrl+C，或者程序访问虚拟内存的一个未定义的区域。应用级并发在其它情况下也是很有用的：

+ <u>访问慢速I/O设备</u> ：当一个应用正在等待来自慢速I/O设备（例如磁盘）的数据到达时，内核会运行其它进程，使CPU保持繁忙。每个应用都可以按照类似的方式，在执行I/O请求的间隙插入其它有用的工作以利用并发。
+ <u>与人交互</u>：和计算机交互的人要求计算机有同时执行多个任务的能力，现代视窗系统利用并发来提供这种能力。每次用户请求某种操作（例如通过单击鼠标）时，一个独立的并发逻辑流被创建来执行这个工作。
+ <u>通过推迟工作以降低延迟</u>：……
+ <u>服务多个网络客户端</u>：实际的服务器需要每秒为成千上万个客户端提供服务。迭代式的网络服务器显然是不可行的，因为它一次只能为一个客户端提供服务，从而拒绝所有其它客户端的服务。并发服务器为每个客户端创建一个单独的逻辑流，因此可以同时为多个客户端服务。
+ <u>在多核机器上完成并行计算</u>：许多现代系统都配备了多核处理器，多核处理器包含有多个CPU。被划分为并发流的应用程序通常在多核机器上比在单核机器上运行得快，因为这些流会并发执行而不是交错执行。

使用应用级并发的应用程序称为**并发程序（concurrent program）**。现代操作系统提供了三种基本的构造并发程序的方法：

+ <u>多进程</u>：这种方法下，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其它流通信，控制流必须使用某种显式的**进程间通信（interprocess communication, IPC）**机制。
+ <u>I/O多路复用</u>：这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一个状态。因为程序是一个单独的进程，所有流都共享同一个地址空间。
+ <u>线程</u>：线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。可以把线程看作是其它两种方式的混合体：像进程流一样由内核进行调度，像I/O多路复用一样共享同一个虚拟地址空间。



# 基于进程的并发编程

构造并发程序最简单的方法就是用进程：在父进程中接受客户端连接请求，由新创建的子进程为每个客户端提供服务。

假设我们有两个客户端和一个服务器，服务器正在监听一个监听描述符（3）上的连接请求。现在假设服务器接受了客户端1的连接请求，并返回一个已连接描述符（4），如图12-1所示。在接受连接请求之后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整副本。子进程关闭它的副本中的监听描述符3，而父进程关闭它的副本中的已连接描述符4，因为已经不再需要。这就得到了图12-2的状态，其中子进程正忙于为客户端提供服务。

图12-1 12-2

因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭它的已连接描述符的副本至关重要。否则将永不释放已连接描述符4的文件表条目，而且由此引起的内存泄露将最终消耗光可用的内存，使系统崩溃。

现在，假设父进程为客户端1创建了子进程之后，它接受一个新的客户端2的连接请求，并返回一个新的已连接描述符（5），如图12-3所示。然后父进程又派生另一个进程，这个子进程用已连接描述符5为它的客户端提供服务，如图12-4所示。此时，父进程正在等待下一个连接请求，而两个子进程正在并发地为它们各自的客户端提供服务。

图12-3 图12-4

## 基于进程的并发服务器

图12-5展示了一个基于进程的并发echo服务器的代码。关于这个服务器，有几点重要内容需要说明：

+ 服务器通常会运行很长的时间，因此我们必须要包括一个SIGCHLD处理程序，来回收僵死子进程的资源（第4~9行）



# 其它并发问题

一旦我们要求同步对共享数据的访问，那么事情就变得复杂得多。这一节讨论写并发问题时需要注意的一些问题。



## 线程安全

当用线程编写程序时，必须小心地编写那些具有称为**线程安全性（thread safety）**属性的函数。一个函数被称为**线程安全的（thread-safe）**，当且仅当被多个并发线程反复地调用时，它总是会产生正确的结果。如果一个函数不是线程安全的，我们就称之为**线程不安全的（thread-unsafe）**。

我们可以定义四种（不相交的）线程不安全函数类：

1. <u>不保护共享变量的函数</u>

