[toc]

假设程序计数器的一个值的序列：
$$
a_o,a_1,\cdots,a_{n-1}
$$
其中 $a_k$ 是某个相应的指令 $I_k$ 的地址。每次从 $a_k$ 到 $a_{k+1}$ 的过渡称为**控制转移（control transfer）**。这样的控制转移序列叫做处理器的**控制流（control flow）**。

最简单的控制流是一个平滑的序列，其中每个 $I_k$ 和 $I_{k+1}$ 在内存中都是相邻的。而控制流的突变（即 $I_k$ 与 $I_{k+1}$ 在不相邻）通常是由诸如跳转、调用和返回这样一些指令造成的。

但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如一个硬件定时器定期产生信号，这个事件必须得到处理；包到达网络适配器后，必须存放在内存中；程序向磁盘请求数据，然后休眠，直到被通知数据已就绪；子进程终止时，创造这些子进程的父进程必须得到通知。

现代系统通过使控制流发生突变来对这些情况做出反应，这些突变称为**异常控制流（Exception Control Flow, ECF）**。异常控制流发生在计算机系统的各个层次：在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序；在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程；在应用层，一个进程可以发送**信号（signal）**到另一个进程，而接收者将控制突然转移到它的一个信号处理程序。程序可以通过回避通常的栈规则，并执行到其它函数中任意位置的非本地跳转来对错误做出反应。

作为程序员，理解ECF很重要，原因如下：

+ 理解ECF将帮助理解重要的系统概念。ECF是操作系统用来实现I/O，进程和虚拟内存的基本机制。
+ 理解ECF将帮助理解应用程序如何与操作系统交互。ECF通过使用一个称为**陷阱（trap）**或者**系统调用（system call）**的ECF形式，向操作系统请求服务，例如向磁盘写数据，从网络读取数据，创建一个新进程，以及终止当前进程等，都是通过应用程序调用系统调用来实现的。
+ 理解ECF将帮助编写应用程序。操作系统为应用程序提供了强大的ECF机制，用来创建新进程、等待进程终止、通知其它进程系统中的异常事件，以及检测和响应这些事件。
+ 理解ECF将帮助理解并发。ECF是计算机系统中实现并发的基本机制。运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，中断应用程序执行的信号处理程序。



# 异常

**异常（exception）**是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。异常是控制流中的突变，用于响应处理器中的某些变化。

图8-1

图中，当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令 $I_{curr}$。在处理器中，状态被编码为不同的位和信号，状态的变化称为**事件（event）**。事件可能和当前指令的执行直接相关，例如发生虚拟内存缺页，算术溢出，除以零，也可能和当前指令的执行没有关系，例如一个系统定时器产生信号或者一个I/O请求完成。

任何情况下，当处理器检测到事件发生时，它就会通过一张叫做**异常表（exception table）**的跳转表，进行一个间接过程调用（异常调用）到一个专门设计用来处理这类事件的操作系统子程序（**异常处理程序（exception handler）**）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下3种情况之一：

1. 处理程序将控制返回给当前指令 $I_{curr}$ 
2. 处理程序将控制返回给下一条指令 $I_{next}$ 
3. 处理程序终止被中断的程序



## 异常处理

<u>系统中每种可能的的异常类型都分配了一个唯一的非负整数的**异常号（exception number）**</u>，其中一些号码由处理器的设计者分配，而其它号码由操作系统内核的设计者分配。前者的示例包括除以零，缺页，内存访问违例，断点以及算术运算溢出，后者的示例包括系统调用和来自外部I/O设备的信号。

<u>在系统启动时，操作系统分配和初始化一张称为**异常表**的跳转表，使得表目k包含异常k的处理程序的地址</u>，如图所示异常表的格式。

图8-2

<u>当执行程序时，处理器检测到发生了一个事件，并且确定了相应的异常号k。随后处理器触发异常，方法是执行间接过程调用，通过异常表的表目k，转到相应的处理程序</u>。如图展示了处理器如何使用异常表生成异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个称为**异常表基址寄存器（exception table base register）**的特殊寄存器里。

图8-3

异常类似于过程调用，但是有一些差异：

+ 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址是当前指令或者下一条指令。
+ 处理器会<u>把一些额外的处理器状态压栈</u>，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64系统会将包含当前条件码的EFLAGS寄存器和其它内容压栈。
+ 如果控制从用户程序转移到内核，<u>所有这些项目都被压到内核栈中</u>，而不是压到用户栈中。
+ <u>异常处理程序运行在内核模式下，这意味着它们对所有的系统资源都有完全的访问权限</u>。



## 异常的类别

异常可以分为四类：**中断（interrupt）**、**陷阱（trap）**、**故障（fault）**和**终止（abort）**。下图对这些类别的属性做了小结。

图8-4



**中断**是异步发生的，是来自处理器外部的I/O设备的信号的结果。硬件中断的异常处理程序常常称为**中断处理程序（interrupt handler）**。

下图概述了一个中断的处理。I/O设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发出信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。

图8-5

在当前指令执行完成之后，处理器注意到中断引脚的电压变高了，于是从系统总线读取异常号，然后调用适当的中断处理程序。当<u>处理程序返回时，它就将控制返回给下一条指令</u>。结果就是<u>程序继续执行，就好像没有发生过中断一样</u>。

中断之外的异常类型是同步发生的，是执行当前指令的结果。这类引起异常的指令称为**故障指令（faulting instruction）**。



**陷阱**是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核中间提供一个像过程一样的接口，称为**系统调用**。

用户程序经常需要向内核请求服务，比如读一个文件（`read`）、创建一个新的进程（`fork`）、加载一个新的程序（`execve`），或者终止当前进程（`exit`）。为了允许对这些内核服务的受控访问，处理器提供了一条特殊的`syscall n`指令，当用户程序想要请求服务n时，可以执行这条指令。执行`syscall` 指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。下图概述了一个系统调用的处理。

图8-6

从程序员的角度来看，系统调用和函数调用是一样的。然而它们的实现非常不同。<u>普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈</u>。<u>系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈</u>。



**故障**由错误情况引起，它可能能够被故障处理程序修正。<u>当故障发生时，处理器将控制程序转移给故障处理程序，如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它</u>。<u>否则处理程序返回到内核中的`abort`例程，`abort`例程会终止引起故障的应用程序</u>。下图概述了一个故障的处理。

图8-7

一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。



**终止**是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被破坏时发生的奇偶错误。<u>终止处理程序从不将控制返回给应用程序</u>。如下图所示，<u>处理程序将控制返回给一个`abort`例程，该例程会终止这个应用程序</u>。

图8-8



## Linux/x86-64系统中的异常

让我们来看x86-64系统定义的一些异常。有高达256种不同的异常类型。0~31对应的是由Intel架构师定义的异常，因此对任何x86-64系统都是一样的；32~255对应的是操作系统定义的中断和陷阱。下图展示了一些示例：

图8-9

**故障和终止**

+ 除法错误：当应用试图除以零，或者一个除法指令的结果对于目标操作数太大的时候（除以近似零），就会发生除法错误（异常0）。Unix不会试图从除法错误中恢复，而是选择终止程序。Linux shell通常把除法错误报告为浮点异常（floating exception）。
+ 一般保护故障：许多原因都会导致一般保护故障（异常13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux不会尝试恢复一般保护故障。Linux shell通常把一般保护错误报告为段故障（segmentation fault）。
+ 缺页：缺页（异常14）是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。
+ 机器检查：机器检查（异常18）是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。

**系统调用**

下图给出了一些常见的Linux系统调用，其中每个系统调用都有一个唯一的整数编号，对应于一个到内核中跳转表的偏移量。（注意这个跳转表和异常表不一样。）

图8-10

C程序用`syscall`函数可以直接调用任何系统调用，但实际上没有必要这么做。对于大多数系统调用，标准C库提供了一组方便的包装函数，这些包装函数将参数打包在一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。本书中，我们将系统调用和它们的包装函数统称为<u>系统级函数</u>。

在x86-64系统上，系统调用通过一条称为`syscall`的陷阱指令来提供。研究程序能够如何使用这条指令来直接调用Linux系统调用十分有趣。所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的，按照惯例，寄存器`%rax`包含系统调用号，寄存器`%rdi`, `%rsi`, `%rdx`, `%r10`, `%r8`, `%r9`包含最多6个参数；从系统调用返回时，寄存器`%rcx`和`%r11`都会被破坏，`%rax`包含返回值，-4095到-1之间的负数返回值表明发生了错误。

例如，考虑`hello`程序的下面这个版本，用系统级函数`write`实现：

```c
int main(){
    write(1, "hello, world\n", 13);
    _exit(0);
}
```

`write`函数的第一个参数将输出发送到`stdout`，第二个参数是要写的字节序列，第三个参数是要写的字节数。

下图给出的是`hello`程序的汇编语言版本，其中使用`syscall`指令来调用`write`和`exit`系统调用。第9~13行调用`write`函数：第9行将系统调用`write`的编号存放在`%rax`中，第10~12行设置参数，第13行使用`syscall`指令来调用系统调用。类似地，第14~16行调用`_exit`系统调用。



# 进程

**进程（process）**是计算机科学中最深刻、最成功的概念之一。在现代操作系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一程序一样。<u>我们的程序好像是独占地使用处理器和内存；处理器好像是无间断地一条接一条地执行我们程序中的指令；程序中的代码和数据好像是系统内存中唯一的对象</u>。这些假象都是通过进程的概念提供给我们的。

进程的经典定义就是一个<u>正在执行的程序实例</u>。<u>系统中的每个程序都运行在某个进程的**上下文（context）**中</u>。上下文由程序正确运行所需的状态组成，这个状态包括存放在<u>内存中的程序的代码和数据</u>，它的<u>栈、通用目的寄存器、程序计数器、环境变量以及打开文件描述符的集合</u>。

每次用户向shell输入一个可执行目标文件的名字，运行程序时，shell就会<u>创建一个新的进程</u>，然后<u>在这个新进程的上下文中运行这个可执行目标文件</u>。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其它应用程序。

操作系统实现进程的细节请参考《现代操作系统》，这里仅讨论进程提供给应用程序的关键抽象：

+ 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器
+ 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统



## 逻辑控制流

即使在系统中通常有许多其它程序在运行，进程也可以向每个程序提供一种假象，好像它在独占地使用处理器。如果用调试器单步执行程序，我们会看到一系列程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件这种的指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个PC值序列称为**逻辑控制流**，或简称**逻辑流**。

考虑一个运行着三个进程的系统，如下图所示，处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。

图8-12

在这个例子中，三个逻辑流的执行是交错的：进程A运行了一会儿，然后进程B开始运行直到完成，然后进程C运行了一会儿，接着进程A运行直到完成，最后进程C运行直到完成。

上图的关键点在于进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被**抢占（preempted）**（暂时挂起），轮到其它进程。



## 并发流

计算机系统中的逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和Java进程都是逻辑流的例子。

一个逻辑流的执行在时间上与另一个流重叠，称为**并发流（concurrent flow）**，这两个流被称为<u>并发地运行</u>。更准确地说，流X和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。例如图8-12中进程A和B、A和C并发地运行，而B和C没有并发地运行。

多个流并发地执行的一般现象称为**并发（concurrency）**；一个进程和其它进程轮流运行的概念称为**多任务（multitasking）**；一个进程执行它的控制流的一部分的每一时间段称为**时间片（time slice）**。因此多任务也称为**时间分片（time slicing）**。

注意并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，<u>即使它们是运行在同一个处理器上</u>。并行流是并发流的一个真子集。如果<u>两个流并发地运行在不同的处理器核或者计算机上</u>，那么我们就称它们为**并行流（parallel flow）**，它们**并行地运行（running in parallel）**。



## 私有地址空间

进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台 $n$ 位地址的机器上，**地址空间**是 $2^n$ 个地址的集合： $0, 1, …,2^n-1$。进程为每个程序提供它自己的**私有地址空间**。一般而言，这个空间中的某个地址相关联的内存字节是不能被其它进程读或者写的，从这个意义上说，这个地址空间是私有的。

尽管每个私有地址空间相关联的内存内容一般是不同的，但是都有相同的通用结构。例如下图展示了一个x86-64 Linux进程的地址空间的组织结构。

图8-13

地址空间的底部保留给用户程序，包括通常的代码、数据、堆和栈段。代码段总是从地址0x400000开始。地址空间顶部保留给内核，包含<u>内核在代表进程执行指令时（例如当应用程序执行系统调用时）使用的代码、数据、栈</u>。



## 用户模式和系统模式

处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。处理器通常用某个控制寄存器中的一个**模式位（mode bit）**来提供这种功能，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在**内核模式**中（也称为**超级用户模式**）。<u>一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置</u>。

没有设置模式位时，进程就运行在**用户模式**中。<u>用户模式中的进程不允许执行**特权指令（privileged instruction）**</u>，比如停止处理器，改变模式位，或者发起一个I/O操作，<u>也不允许直接引用地址空间中内核区内的代码和数据</u>。反之，<u>用户程序必须通过系统调用接口间接地访问内核代码和数据</u>。

运行应用程序代码的进程初始时处于用户模式，<u>进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常</u>。<u>当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式</u>。<u>处理程序运行在内核模式中，使用地址空间顶部，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式</u>。

Linux提供了一种聪明的机制，叫做`/proc`文件系统，它<u>允许用户模式进程访问内核数据结构的内容</u>。`/proc`文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用`/proc`文件系统找出一般的系统属性，比如CPU类型（`/proc/cpuinfo`），或者某个特定的进程使用的内存段（`/proc/<process-id>/maps`）。2.6版本的Linux内核引入`/sys`文件系统，它输出关于系统总线和设备的额外的底层信息。



## 上下文切换

操作系统内核使用一种称为**上下文切换（context switch）**的较高层形式的异常控制流来实现多任务。上下文切换机制建立在异常部分讨论过的较底层异常机制之上。

内核为每个进程维持一个**上下文（context）**。上下文就是<u>内核重新启动一个被抢占的进程所需的状态</u>。它由一些对象的值组成，包括<u>通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构</u>，比如描述地址空间的**页表**、包含当前进程信息的**进程表**，以及包含进程已打开文件的信息的**文件表**。

在进程执行的某些时刻，内核可以决定<u>抢占当前进程，并重新开始一个先前被抢占了的进程</u>。这种决策就称为**调度（scheduling）**，由内核中称为**调度器（scheduler）**的代码处理。当内核选择一个新的进程运行后（称内核调度了这个进程），内核就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程中，上下文切换

+ <u>保存当前进程的上下文</u>
+ <u>恢复某个先前被抢占的进程被保存的上下文</u>
+ <u>将控制传递给这个被恢复的进程</u>

当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个`read`系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。

下图展示了一对进程A和B之间上下文切换的示例。

图8-14

在这个例子中，进程A初始运行在用户模式中，直到它通过执行系统调用`read`陷入到内核。内核的陷阱处理程序请求来自磁盘控制器的DMA传输，并且安排<u>在磁盘控制器完成磁盘到内存的数据传输后，磁盘中断处理器</u>。

磁盘取数据要用一段相对较长的时间（大约几十毫秒），所以内核执行从进程A到进程B的上下文切换，而不是在这个间歇时间内等待。注意在切换之前，（内核代表）进程A在用户模式下执行指令；在切换过程中，内核代表进程A在内核模式下执行指令，然后在某一时刻切换为，代表进程B在内核模式下执行指令；切换之后，（内核代表）进程B在用户模式下执行指令。

随后，进程B在用户模式下运行一会，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程B已经运行了足够长的时间，就执行一个从进程B到进程A的上下文切换，将控制返回给进程A中紧随在系统调用`read`之后的那条指令。进程A继续运行，直到下一次异常发生。





# 进程控制

## 获取进程ID

每个进程都有一个唯一的正整数进程ID（PID）。`getpid`函数返回调用进程的PID，`getppid`函数返回其父进程的PID。

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
    // return PID of caller process
pid_t getppid(void);
    // return PID of parent process of caller process
```

`getpid`和`getppid`函数返回一个类型为`pid_t`的整数值，其在`types.h`中被定义为`int`。



## 创建和终止进程

从程序员的角度，我们可以认为进程总是处于下面三种状态之一：

+ **运行**：进程正在由处理器执行指令，或者等待被执行且之后会被内核调度
+ **停止**：进程的执行被**挂起（suspended）**，且不会被调度。当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号时，进程就会停止，并且保持停止直到它收到一个SIGCONT信号，此时进程再次开始运行。
+ **终止**：进程永远地停止了。进程会因为三种原因终止：1) 收到一个信号，该信号的默认行为是终止进程；2) 从`main()`返回；3) 调用`exit`函数。

```c
#include <stdlib.h>
void exit(int status);
```

`exit`函数以`status`**退出状态**来终止进程（另一种设置退出状态的方法是从`main()`中返回一个整数值）。

**父进程**通过调用`fork`函数创建一个新的**子进程**：

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
    // child process returns 0, parent process returns PID of child process or -1 if err
```

新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同（但是独立）的一个副本，因此子进程可以读写父进程打开的任何文件。父进程和子进程之间的最大的区别在于它们有不同的PID。

`fork`函数是有趣的（也令人迷惑），因为它调用一次，却返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中`fork`返回子进程的PID，在子进程中`fork`返回0；返回值提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。

下图展示了一个使用`fork`创建子进程的父进程的示例。当`fork`调用在第6行返回时，在父进程和子进程中`x`的值都为1。子进程在第8行加一并输出它的`x`的副本，父进程则在第13行减一并输出它的`x`的副本。

图8-15

在Unix系统上运行时将得到以下结果：

```
linux> ./fork
parent: x=0
child : x=2
```

这个简单的例子有一些微妙的细节：

+ <u>调用一次，返回两次</u>：`fork`函数被父进程调用一次，但是却返回两次——一次返回到父进程，一次返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的；但是对于多次调用`fork`函数的程序可能就会令人迷惑，需要仔细推敲了。
+ <u>并发执行</u>：父进程和子进程是并发运行的独立进程，内核能够以任意方式交替执行它们的逻辑控制流中的指令。上面的运行结果表明父进程先于子进程完成`printf`语句，但也可能出现相反的结果。我们绝不能对不同进程中指令的交替执行做任何假设。
+ <u>相同但是独立的地址空间</u>：如果能够在`fork`函数返回后立即暂停父进程和子进程，我们会看到这两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的局部变量值、相同的堆、相同的全局变量值以及相同的代码。因此在`fork`函数返回后，局部变量`x`在父进程和子进程中都为1。然而，父进程和子进程是独立的进程，有独立的私有地址空间，因此后面父进程和子进程对`x`所做的任何改变都是独立的，不会反映在另一个进程的内存中。
+ <u>共享文件</u>：我们注意到父进程和子进程都把各自的输出显示在shell中，原因是子进程继承了父进程所有的打开文件。当父进程调用`fork`时，`stdout`文件是打开的，并且指向屏幕；子进程继承了这个文件，因此它的输出也指向屏幕。

在学习`fork`函数的过程中，画进程图通常会有所帮助。进程图是刻画程序语句的偏序的一种简单的前趋图，每个定点对应于一条程序语句的执行。有向边 $a\to b$ 表示语句 $a$ 发生在语句 $b$ 之前。边上可以标记一些信息，例如一个变量的当前值，`print`语句的打印结果。每张图开始于`main`调用，结束于`exit`调用。例如，下图展示了图8-15的示例程序的进程图。

图8-16

对于运行在单处理器上的程序，对应进程图中所有顶点的拓扑排序（topological sort）表示程序中语句的一个可行的全序排列。一个理解拓扑排序概念的简单方法是，给定进程图中顶点的一个排列并从左到右写成一行，然后画出每条有向边，排列是一个拓扑排序当且仅当画出的每条边的方向都是从左往右的。

进程图特别有助于理解带有嵌套`fork`调用的程序，例如下图中的程序源码两次调用了`fork`。对应的进程图可以帮助我们看清这个程序运行了四个进程，每个都调用了一次`printf`，这些`printf`可以以任意顺序执行。

图8-17



## 回收子进程

当一个进程因为某种原因终止时，内核并不是立即将其从系统中清除。相反，<u>进程被保持在一种已终止的状态中，直到被它的父进程**回收（reaped）**</u>。当父进程回收已终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃已终止的进程，从这时开始该进程就不再存在了。一个终止了但还未被回收的进程称为**僵死进程（zombie）**，僵死进程仍然占用系统的内存资源。

`init`进程的PID为1，是在系统启动时由内核创建的，是所有进程的祖先。如果一个父进程先于它的子进程终止，内核会安排`init`进程成为它的孤儿进程的养父，并在它们终止时进行回收。长时间运行的程序，例如shell或服务器，应该总是回收它们的僵死子进程。

进程可以调用`waitpid`函数来等待它的子进程终止：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
    //return PID of child process if success, 0 if WNOHANG, -1 if other err
```

默认情况下，即`options=0`时，`waitpid`挂起调用进程的执行，直到它的**等待集合（wait set）**中的某一个子进程终止。如果等待集合中的一个进程在调用之前就已经终止了，那么`waitpid`就立即返回。这种情况中`waitpid`返回导致其返回的已终止子进程的PID。此时<u>已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹</u>。

**等待集合**

等待集合由参数`pid`确定：

+ 如果`pid > 0`，那么等待集合就是PID为`pid`的指定子进程
+ 如果`pid = -1`，那么等待集合就是父进程的所有子进程

**修改默认行为**

可以修改`options`为常量`WNOHANG`，`WUNTRACED`，`WCONTINUED`的各种组合来修改默认行为：

+ `WNOHANG` 如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回0）。在等待子进程终止的同时，如果还想做些有用的工作，可以使用这个选项。
+ `WUNTRACED` 挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回导致返回的已终止或被停止的子进程的PID。这个选项可以用于检查已终止或被停止的子进程。
+ `WCONTINUED` 挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到SIGCONT信号重新开始执行。
+ `WNOHANG|WUNTRACED` 立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为0；如果有一个停止或终止，则返回值为该子进程的PID

**检查已回收子进程的退出状态**

如果`statusp`参数是非空的，那么`waitpid`就会在`statusp`指向的位置写入关于导致返回的子进程的状态信息。`wait.h`头文件定义了几个宏用于解释`status`参数：

+ `WIFEXITED(status)`：如果子进程通过调用`exit`或者返回而正常终止，则返回真
+ `WEXITSTATUS(status)`：返回一个正常终止的子进程的退出状态
+ `WIFSIGNALED(status)`：如果子进程是因为一个未被捕获的信号终止的，则返回真
+ `WTERMSIG(status)`：返回导致子进程终止的信号的编号
+ `WIFSTOPPED(status)`：如果引起返回的子进程当前是停止的，则返回真
+ `WSTOPSIG(status)`：返回引起子进程停止的信号的编号
+ `WIFCONTINUED(status)`：如果子进程收到SIGCONT信号重新启动，则返回真

**错误条件**

如果调用进程没有子进程，那么`waitpid`返回-1，并且设置`errno`为ECHILD；如果`waitpid`被一个信号中断，那么它返回-1，并设置`errno`为EINTR。

**`wait`函数**

`wait`函数是`waitpid`函数的简单版本：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int *statusp);
    // equals waitpid(-1, &status, 0)
```

**`waitpid`实例**

第一个程序使用`waitpid`，不按照特定的顺序等待它的所有N个子进程终止。

图8-18

第11行，父进程创建N个子进程。第12行，每个子进程以唯一的退出状态退出。第15行，父进程用`waitpid`作为`while`循环的测试条件，等待它所有的子进程终止。每个子进程终止时，对`waitpid`的调用都会返回，返回值为该子进程的非零的PID。第16行检查子进程是否正常终止，如果是（此处为调用`exit`函数终止），则父进程将退出状态输出到`stdout`上。

当回收了所有的子进程之后，再调用`waitpid`就返回-1，并且设置`errno`为ECHILD。第24行检查`waitpid`函数是否正常终止，否则就输出一个错误信息。

在Linux系统上运行这个程序时，它产生以下输出：

```c
linux> ./waitpid1
child 22966 terminated normally with exit status=100
child 22967 terminated normally with exit status=101
```

注意程序不会按照特定的顺序回收子进程，这是一个非确定性行为。作为程序员绝对不能假设出现哪一种结果。想要按顺序回收子进程，可以存储每个子进程的PID，然后按顺序等待每个子进程。



## 休眠进程

`sleep`函数将一个进程挂起一段指定的时间。

```c
#include <unistd.h>
unsigned int sleep(unsigned int secs);
	// return secs remained to be sleep
```

如果进程休眠了指定的时间，那么`sleep`返回0；如果`sleep`函数被一个信号中断而返回，那么返回剩余要休眠的秒数。

`pause`函数让调用函数休眠，直到该进程收到一个信号。

```c
#include <unistd.h>
int pause(void);
    // return -1
```



## 加载并运行程序

`execve`函数在当前进程的上下文中加载并运行一个新程序。

```c
#include <unistd.h>

int execve(const char *filename, const char *argv[],
           const char *envp[]);
    // not return if succeed, return -1 if err
```

`execve`函数加载并运行可执行目标文件`filename`，且带参数列表`argv`和环境变量列表`envp`。只有当出现错误时，例如找不到`filename`，`execve`才会返回到调用程序。因此与`fork`调用一次返回两次相对照地，`execve`调用一次不返回。

参数列表如下图的数据结构所示，`argv`变量指向一个以null结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，`argv[0]`是可执行目标文件的名字。环境变量的列表由一个类似的数据结构表示，如图8-21所示。`envp`变量指向一个以null结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如`name=value`的名称-值对。

图8-20 8-21

在`execve`加载了`filename`之后，它调用加载器设置栈，并将控制传递给新程序的主函数。该主函数具有如下形式的原型：

```c
int main(int argc, char **argv, char **envp);
```

当`main`开始执行时，用户栈的组织结构如下图所示。从栈底到栈顶，首先是环境字符串和参数；随后是以null结尾的指针数组，其中每个指针都指向栈中的一个环境字符串；随后是以null结尾的`argv[]`数组，其中每个元素都指向栈中的一个参数字符串；栈顶是系统启动函数`libc_start_main`的栈帧。

图8-22

`main`函数有3个参数：

1. `argc`：给出`argv[]`数组中非空指针的数量
2. `argv`：指向`argv[]`数组的第一个条目
3. `envp`：指向`envp[]`数组的第一个条目

Linux提供了几个函数来操作环境数组：

```c
#include <stdlib.h>

char *getenv(const char *name);
    // return a pointer to name if exist, NULL if not
```

`getenv`函数在环境数组中搜索字符串`name=value`，如果找到了则返回一个指向`value`的指针，否则返回`NULL`。

```c
#include <stdlib.h>

char setenv(const char *name, const char *newvalue, int overwrite);
    // return 0 if succeed, -1 if err
void unsetenv(const char *name);

```

如果环境数组包含一个形如`name=oldvalue`的字符串，那么`unsetenv`会删除它，而`setenv`会用`newvalue`替代`oldvalue`，但是只有在`overwrite`非零时才会如此。如果`name`不存在，那么`setenv`就把`name=newvalue`添加到数组中。

> 回顾一下，`execve`函数在当前进程的上下文中加载并运行一个新的程序，它会覆盖当前进程的地址空间，但并没有创建一个新进程，并且会继承调用`execve`函数时已打开的所有文件的描述符。





# 信号

本节将讨论一种更高层的软件形式的异常，称为Linux信号，它允许进程和内核中断其它进程。

一个**信号**就是一条消息，它通知进程系统中发生了一个某种类型的事件。如图展示了Linux系统上支持的30种不同类型的信号。

图8-26

每种信号都对应于某种系统事件。<u>底层的硬件异常是由内核异常处理程序处理的</u>，正常情况下对于用户进程不可见，信号提供了一种机制，能够通知用户进程发生了这些异常：例如如果一个进程试图除以零，那么内核就发送给它一个SIGFPE信号（8）；如果一个进程执行一条非法指令，那么内核就发送给它一个SIGILL信号（4）；如果进程进行非法内存引用，内核就发送给它一个SIGSEGV信号（11）。其它信号对应于内核或者其它用户进程中较高层的软件事件：例如进程在前台运行时，键入Ctrl+C，内核就会发送一个SIGINT信号（2）给这个前台进程组中的每个进程；一个进程可以通过向另一个进程发送SIGKILL信号（9）强制终止它；子进程终止或停止时，内核会发送一个SIGCHLD信号（17）给父进程。



## 信号术语

传送一个信号到目的进程由两个不同的步骤组成：

+ 发送信号：<u>内核通过更新目的进程上下文中的某个状态，发送一个信号给目的进程</u>。发送信号可以有如下两种原因：1）<u>内核检测到一个系统事件</u>，比如除零错误或者子进程终止；2）一个进程调用了`kill`函数，显式地要求内核发送一个信号给目的进程。进程可以发送信号给它自己。
+ 接受信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止，或通过执行一个称为**信号处理程序（signal handle）**的用户层函数捕获这个信号。下图给出了信号处理程序捕获信号的基本思想。

图8-27

一个发出而没有被接收的信号称为**待处理信号（pending signal）**。在任何时刻，<u>一种类型的待处理信号至多只能有一个</u>。如果一个进程有一个类型为k的待处理信号，那么任何接下来发送到这个进程的类型为k的信号都不会排队等待，而是简单地被丢弃。一个进程可以有选择地阻塞接收某种信号；<u>当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞</u>。

内核为每个进程在`pending`位向量中维护着待处理信号的集合，而在`blocked`位向量中维护着被阻塞的信号集合。只要向进程传送了一个类型为k的信号，内核就会设置`pending`中的第k位；而只要接收了一个类型为k的信号，内核就会清除`pending`中的第k位。



## 发送信号

Unix系统提供了大量项进程发送信号的机制，所有这些机制都基于**进程组（process group）**的概念。

### 进程组

每个进程都属于且仅属于一个进程组。进程组由一个正整数进程组ID标识，`getpgrp`函数返回当前进程的进程组ID：

```c
#include <unistd.h>

pid_t getpgrp(void);
    // return id of process group of process
```

默认地，<u>一个子进程和它的父进程同属一个进程组</u>。一个进程可以通过使用`setpgid`函数来改变自己或者其它进程的进程组：

```c
#include <unistd.h>

int setpgid(pid_t pid, pid_t pgid);
    // return 0 if succeed, -1 if err
```

`setpgid`函数将进程`pid`的进程组改为`pgid`。若`pid`为0，则使用当前进程的PID；若`pgid`为0，则使用指定进程的PID作为进程组ID。例如，如果进程15213是调用进程，那么`setpgid(0, 0);`会创建一个新的进程组，其进程组ID为15213，并且把进程15213加入到这个新的进程组中。



### /bin/kill发送信号

`/bin/kill`程序可以向另外的进程发送任意信号，例如

```shell
linux> /bin/kill -9 15213
```

发送信号9（SIGKILL）给进程15213。负的PID表示进程组ID，例如

```shell
linux> /bin/kill -9 -15213
```

发送SIGKILL信号给进程组15213中的每个进程。

注意这里我们使用完整路径`/bin/kill`，因为有些Unix shell有自己内置的`kill`命令。



### 从键盘发送信号

Unix shell使用**作业（job）**这个抽象表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和任意个后台作业。

> shell是一个交互型应用程序，它代表用户运行其它程序。shell执行一系列的**读/求值（read/evaluate）**步骤，然后终止。读步骤读取来自用户的一个命令行，求值步骤解析命令行，并代表用户运行程序。

例如，键入

```shell
linux> ls | sort
```

会创建一个由两个进程组成的前台作业，这两个进程通过Unix管道连接起来：一个进程运行`ls`程序，另一个运行`sort`程序。shell为每个作业创建一个独立的进程组，进程组ID通常取自作业中的父进程。例如下图展示了有一个前台作业和两个后台作业的shell，前台作业中的父进程PID为20，进程组ID也为20，父进程创建两个子进程，每个也都是进程组20的成员。

图8-28

在键盘上输入Ctrl+C会导致内核发送一个SIGINT信号到前台进程组的每个进程，默认情况下终止前台作业。类似地，输入Ctrl+Z会发送一个SIGSTP信号到前台进程组的每个进程，默认情况下停止（挂起）前台作业。



### 用`kill`函数发送信号

进程通过调用`kill`函数发送信号给其它进程（包括它自己）。

```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
    // return 0 if succeed, -1 if err
```

如果`pid`大于零，`kill`函数发送信号`sid`给进程`pid`；如果`pid`等于零，`kill`函数发送信号`sid`给调用进程所在进程组中的每个进程，包括调用进程自己；如果`pid`小于零，`kill`函数发送信号`sid`给进程组`|pid|`（`pid`的绝对值）中的每个进程。下图展示了一个示例，父进程用`kill`函数发送SIGKILL信号给它的子进程。



### 用`alarm`函数发送信号

进程可以通过调用`alarm`函数向它自己发送SIGALRM信号。

```c
#include <unistd.h>

unsigned int alarm(unsigned int secs);
    // 
```











## 接收信号



## 编写信号处理程序

信号处理是Linux系统编程中最棘手的一个问题





**安全的信号处理**

信号处理程序很麻烦是因为它们和主程序以及其它信号处理程序并发地运行。如果处理程序和主程序并发地访问同一个全局数据结构，那么结果就会不可预知，而且经常是致命的。这里提供一些保守的编写处理程序的原则，意在使得这些处理程序能够安全地并发运行：

1. <u>处理程序要尽可能简单</u> 例如处理程序只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地检查（并重置）这个标志。
2. <u>在处理程序中只调用异步信号安全的函数</u> **异步信号安全**的函数能够被信号处理程序安全地调用，原因或者是它是可重入的，或者是它不能被信号处理程序中断。如图列出了Linux保证安全的函数。
3. <u>保存和恢复`errno`</u>



**正确的信号处理**

未处理的信号是不排队的，因为`pending`位向量中每种类型的信号只对应一位。如果存在一个未处理的信号就表明至少有一个信号到达了。