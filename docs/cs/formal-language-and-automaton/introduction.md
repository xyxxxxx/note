介绍3个基本概念。

## 语言

我们每个人都十分熟悉自然语言，然而却发现想要准确地解释“语言”是什么却并不容易。我们希望给**语言（language）**一个更准确的定义。

首先给出一个有限的、非空的符号集合 $\Sigma$，称为**字母表（alphabet）**。使用字母表可以构造出**符号串（string）**，这个符号串是字母表中符号的有穷序列。我们一般使用 $a,b,c,\cdots$ 来表示 $\Sigma$ 中的元素，使用 $u,v,w,\cdots$ 来表示符号串的名字，例如 $w=abaaa$。

符号串 $w$ 和 $v$ 的**连接（concatenation）**是把 $v$ 添加到 $w$ 的右端。符号串的**逆（reverse）**是把符号串中的符号按照相反的顺序列出。符号串 $w$ 的**长度（length）**，记作 $|w|$，指符号串中包含的符号个数。**空串（empty string）**中没有任何符号，用 $\lambda$ 表示。

符号串 $w$ 中任何连贯的符号构成的符号串称为 $w$ 的**子串（substring）**。如果 $w=vu$，那么子串 $v$ 和子串 $u$ 分别是 $w$ 的**前缀（prefix）**和**后缀（suffix）**。

对于符号串 $w$， $w^n$ 表示重复这个符号串 $n$ 次，并且定义 $w^0=\lambda$。

对于字母表 $\Sigma$， $\Sigma^*$ 表示连接 $\Sigma$ 中的零个或多个符号获得的所有符号串的集合， $\lambda \in\Sigma^*$， $\Sigma^+$ 定义为 $\Sigma^+=\Sigma^*-\{\lambda\}$。 $\Sigma$ 是有限的，但 $\Sigma^*$ 和 $\Sigma^+$ 是无限的。

语言 $L$ 通常定义为 $\Sigma^*$ 的子集， $L$ 中的一个符号串称为**句子（sentence）**。例如， $\Sigma=\{a,b\}$，那么 $\Sigma^*=\{\lambda,a,b,aa,ab,ba,bb,\cdots\}$。集合 $L=\{a,aa,aab\}$ 是 $\Sigma$ 上的一种有限语言，其包含有限个句子；集合 $L=\{a^nb^n:n\ge0\}$ 是 $\Sigma$ 上的一种无限语言。

由于语言也是集合，因此可以定义语言的交、并、补、差。全集 $\Sigma^*$ 上定义语言 $L$ 的**补集**为
$$
\overline{L}=\Sigma^*-L
$$
语言 $L$ 的**逆**定义为
$$
L^R=\{w^R:w\in L\}
$$
语言 $L_1$ 和 $L_2$ 的**连接**指的是 $L_1$ 中的任意元素和 $L_2$ 中的任意元素通过连接形成的所有符号串的集合，表示为
$$
L_1L_2=\{xy:x\in L_1,y\in L_2\}
$$
定义 $L^n$ 为 $L$ 自身连接 $n$ 次，特殊地， $L^0=\{\lambda\}$，例如， $L=\{a^nb^n:n\ge 0\}$，那么
$$
L^2=\{a^nb^na^mb^m:n\ge 0,m\ge 0\}
$$
定义语言 $L$ 的**星闭包（star-closure）**为
$$
L^*=L^0\cup L^1\cup L^2\cdots
$$
**正闭包（positive closure）**为
$$
L^+=L^1\cup L^2\cdots
$$

## 文法

使用集合的表示依然是有局限性的，接下来我们将介绍几种应用在不同环境中的语言定义机制。

**定义** **文法（grammar）**是一个四元组
$$
G=(V,T,S,P)
$$
其中，

+ $V$ 是对象的有限集合，称为**变量（variable）**
+ $T$ 是对象的有限集合，称为**终结符（terminal symbol）**
+ $S\in V$ 是一个特殊符号，称为**开始符（start variable）**
+ $P$ 是**产生式（production）**的有限集合

产生式是文法的核心，它们指出文法如何把一个符号串转化成另一个符号串。在我们的讨论中，假设所有的产生式都表示为如下形式：
$$
x\to y
$$
其中 $x$ 是 $（V\cup T)^+$ 中的元素， $y$ 属于 $(V\cup T)^*$。如果符号串 $w=uxv,z=uyv$，那么有
$$
w\Rightarrow z
$$
这时我们称 $w$ **推导（derive）**出 $z$。如果
$$
w_1\Rightarrow w_2 \Rightarrow\cdots \Rightarrow w_n
$$
我们称 $w_1$ 推导出 $w_n$，并记作
$$
w_1\Rightarrow^*w_n
$$
**定义** 设 $G=(V,T,S,P)$ 是一个文法，那么集合
$$
L(G)=\{w\in T^*:S\Rightarrow^*w\}
$$
就是文法 $G$ 生成的语言。对于 $w\in L(G)$，序列
$$
S\Rightarrow w_1\Rightarrow w_2 \Rightarrow\cdots \Rightarrow w_n\Rightarrow w
$$
就是句子 $w$ 的一个**推导（derivation）**，符号串 $S,w_1,\cdots,w_n$ 称为推导的**句型（sentential form）**。

@例如，文法
$$
G=(\{S\},\{a,b\},S,P)
$$
其中， $P$ 定义为
$$
S\to aSb\\
S\to \lambda
$$
因此有
$$
S\Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb
$$
即
$$
S \Rightarrow^* aabb
$$
文法 $G$ 完全定义了一个语言 $L(G)$，不难证明
$$
L(G)=\{a^nb^n:n\ge 0\}
$$
如果两个文法 $G_1$ 和 $G_2$ 产生相同的语言，即
$$
L(G_1)=L(G_2)
$$
我们就称这两种文法是**等价的（equivalent）**。

> 两种文法的等价性在很多情况下并不容易直接看出

## 自动机

自动机是数字计算机的抽象模型：

+ 自动机有一个读入装置，**输入文件（input file）**是给定字母表上的一个符号串；自动机只能读入输入文件而不能修改；输入文件被分为若干个单元，每个单元存放一个符号，读入装置从左到右读入，一次读入一个符号；读入装置能识别串的尾部。

+ 自动机有一个临时**存储（storage）**设备，其包含无限个单元，每个单元存放一个符号，自动机可以读写存储单元的内容。

+ 自动机有一个**控制部件（control unit）**，这个控制部件可以处于有限个**内部状态（internal state）**中的任何一个。

+ 自动机能够生成某种形式的输出。

![Screenshot from 2020-09-10 16-28-36.png](https://i.loli.net/2020/09/10/aqW4AmDCuo6KiBd.png)

根据假定，自动机是在离散时间框架上操作的，即在任意给定的时间点上，控制部件处于某个内部状态，输入装置正在搜索输入文件上的下一个符号。下一时刻控制部件会处于哪个内部状态由**下一个符号**和**状态转移函数（state transition function）**决定：状态转移函数根据当前状态、当前读入符号和临时存储空间中的当前信息来决定下一个状态，同时产生输出或改变临时存储空间的信息。**格局（configuration）**指控制部件、输入文件和临时存储空间的某个特定状态，自动机从一个格局到另一个格局的转换称为**迁移（move）**。

我们必须区分**确定型自动机（deterministic automata）**和**非确定型自动机（nondeterministic automata）**。确定型自动机指根据当前的格局，自动机的每一步都是唯一确定的，即如果我们知道内部状态、输入和临时存储空间的内容，我们就可以准确地预测自动机的下一步行为。然而在非确定型自动机中，每一点上自动机都有几个可能的迁移，因此我们只能得到一个可能行为的预测集合。

如果一个自动机的输出响应仅有yes和no的话，这个自动机就是**接受器（accepter）**。一个更通用的自动机能够输出和输入相同的符号，这种自动机称为**转换器（transducer）**。