# threading——基于线程的并行

`threading` 模块在较低级的 `_thread` 模块的基础上建立了较高级的线程接口。

!!! note "注意"
    在 CPython 中，由于存在全局解释器锁，同一时刻只有一个线程可以执行 Python 代码（虽然某些性能导向的库可能会去除此限制）。如果你想让你的应用更好地利用多核心计算机的计算资源，推荐你使用 `multiprocessing` 或 `concurrent.futures.ProcessPoolExecutor`。 但是，如果你想要同时运行多个 I/O 密集型任务，则多线程仍然是一个合适的模型。

## active_count()

返回当前存活的 `Thread` 对象的数量。

## current_thread()

返回当前调用者的控制线程的 `Thread` 对象。如果调用者的控制线程不是由 `threading` 模块创建，则会返回一个功能受限的虚拟线程对象。

## enumerate()

以列表形式返回当前所有存活的 `Thread` 对象。该列表包含守护线程、`current_thread()` 创建的虚拟线程对象和主线程，但不包含已终止的线程和尚未开始的线程。

## get_indent()

返回当前线程的“线程标识符”。它的值是一个正整数，没有直接含义，主要是用作 magic cookie，比如作为包含线程相关数据的字典的索引。线程标识符可能会在线程退出、新线程创建时被复用。

## get_native_id()

返回内核分配给当前线程的原生集成线程 ID。它的值是一个非负整数，可以被用来在整个系统中唯一地标识这个特定线程（直到线程终结，在那之后该值可能会被 OS 回收再利用）。

## main_thread()

返回主 `Thread` 对象。

## Thread

`Thread` 类代表在一个独立的控制线程中运行的活动。有两种指定活动的方法：通过向构造器传入一个可调用对象，或通过重载子类的 `run()` 方法。换言之，只可以重载此类的 `__init__()` 和 `run()` 方法。

一旦线程对象被创建，其活动必须通过调用线程的 `start()` 方法启动。这会在一个独立的控制线程中调用 `run()` 方法。

一旦线程活动开始，该线程会被认为是“存活的”。当它的 `run()` 方法终止了（不管是正常的还是抛出未被处理的异常），就不再是“存活的”。`is_alive()` 方法用于检查线程是否存活。

其他线程可以调用一个线程的 `join()` 方法。这会阻塞调用线程，直到被调用 `join()` 方法的线程终止。

线程有名称。名称可以传递给构造函数，也可以通过 `name` 属性读取或者修改。

如果 `run()` 方法引发了异常，则会调用 `threading.excepthook()` 来处理它。在默认情况下，`threading.excepthook()` 会静默地忽略 `SystemExit`。

一个线程可以被标记为“守护线程”。这个标识的意义是，当剩下的线程都是守护线程时，整个 Python 程序将会退出。初始值继承于创建线程。这个标识可以通过 `daemon` 属性或者 `daemon` 构造器参数来设置。

!!! note "注意"
    守护线程在程序关闭时会突然关闭，它们的资源（例如已经打开的文档、数据库事务等）可能不会被正确释放。如果你想要你的线程正常停止，设置它们成为非守护模式并且使用合适的信号机制，例如：`Event`。

Python 程序初始的控制线程是“主线程”对象，它不是一个守护线程。

可以创建“虚拟线程对象”，它们是对应于“外部线程”的线程对象。“外部线程”是在 `threading` 模块之外启动的控制线程，例如直接来自 C 代码。虚拟线程对象的功能受限：它们总是被认为是存活的和守护的，不能被 `join()`。因为无法检测外来线程的终止，它们永远不会被删除。

```python
class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)
# group    应为None,为日后扩展而保留
# target   用于`run()`方法调用的可调用对象.默认为None,表示不需要调用任何方法
# name     线程名称.默认为"Thread-N"格式,其中N是从1开始的正整数
# args     用于调用目标函数的位置参数元组
# kwargs   用于调用目标函数的关键字参数字典
# daemon   若为True/False,设置该线程为/不为守护线程;若为None,线程将继承当前线程的守护模式
```

如果子类重载了构造函数，那么它一定要确保在做任何事之前，先调用基类的构造函数(`Thread.__init__()`)。

### start()

开始线程活动。

此方法安排对象的 `run()` 方法在一个独立的控制进程中调用。

每个线程对象只能调用一次此方法。一个线程对象第二次调用此方法将引发 `RuntimeError`。

### run()

代表线程活动的函数。

你可以在子类中重载这个方法。标准的 `run()` 方法会对作为 *target* 参数传递给构造器的可调用对象（如果存在）发起调用，并附带从 *args* 和 *kwargs* 参数分别获取的位置和关键字参数。

### join()

```python
join(timeout=None)
```

等待，直到线程终止。这会阻塞调用 `join()` 的线程，直到被调用 `join()` 的线程终止——不管是正常终止还是抛出未处理异常——或者直到发生超时，超时选项是可选的。

当 *timeout* 参数存在且不是 `None` 时，它应该是一个用于指定操作超时的以秒为单位的浮点数。因为 `join()` 总是返回 `None`，所以你只能在 `join()` 后调用 `is_alive()` 才能判断是否发生超时——如果线程仍然存活，则 `join()` 超时。

当 *timeout* 参数不存在或者是 `None`，这个操作会阻塞直到线程终止。

一个线程可以被 `join()` 很多次。

尝试 `join()` 当前线程或一个尚未开始的线程将引发 `RuntimeError` 异常。

### name

线程的名称，仅用于识别线程，没有语义。多个线程可以赋予相同的名称。初始名称由构造函数设置。

### ident

线程的“线程标识符”，是一个正整数，如果线程尚未开始则为 `None`。当一个线程退出而另外一个线程被创建时，线程标识符会被复用。即使线程已经退出，仍可以得到其标识符。

### native_id

此线程的原生集成线程 ID，是一个非负整数，如果线程尚未开始则为 `None`。该值的存在表示线程 ID（TID）已被操作系统（内核）赋值给线程。该值可以被用来在全系统范围内唯一地标识这个特定线程（直到线程终止，在那之后该值可能会被操作系统回收再利用）。

!!! note "注意"
    类似于进程 ID，线程 ID 的有效期（全系统范围内保证唯一）将从线程被创建开始直到线程终止。

可用性: 需要 `get_native_id()` 函数。

### is_alive()

返回线程是否存活。

从 `run()` 方法刚开始之前到 `run()` 方法刚结束之后，此方法返回 True。模块函数 `enumerate()` 返回包含所有存活线程的列表。

### daemon

一个表示该线程是否是守护线程的布尔值。一定要在调用 `start()` 前设置好，否则会引发 `RuntimeError`。初始值继承自创建线程；主线程不是守护线程，因此主线程创建的所有线程默认都是 `daemon = False`。

当没有存活的非守护线程时，整个 Python 程序才会退出。

## Lock

原始锁是一个在锁定时不属于特定线程的同步基元组件。在 Python 中，它是可以使用的最低级的同步基元组件，由 `_thread` 扩展模块直接实现。

原始锁处于“锁定”或者“非锁定”两种状态之一，在创建时为非锁定状态。它有两个基本方法，`acquire()` 和 `release()`。当状态为非锁定时，`acquire()` 将状态改为锁定并立即返回；当状态是锁定时，`acquire()` 将阻塞至其他线程调用 `release()` 将其改为非锁定状态，然后 `acquire()` 重置其为锁定状态并返回。`release()` 只在锁定状态下调用，将状态改为非锁定并立即返回。如果尝试释放一个非锁定的锁，则会引发 `RuntimeError` 异常。

原始锁支持上下文管理协议。

当多个线程在 `acquire()` 阻塞，然后 `release()` 重置状态为未锁定时，只有一个线程能继续执行；至于哪个线程继续执行则没有定义，并且会根据实现而不同。

所有方法的执行都是原子性的。

```python
class threading.Lock
```

实现原始锁对象的类。一旦一个线程获得一个锁，之后尝试获得同一个锁的线程会阻塞，直到它被释放；任何线程都可以释放它。

需要注意的是 `Lock` 其实是一个工厂函数，返回平台支持的具体锁类中最有效的版本的实例。

### acquire()

```python
acquire(blocking=True, timeout=-1)
```

阻塞或非阻塞地获得锁。

*blocking* 设为 True 调用此方法，会一直阻塞直到锁被释放，然后将锁锁定并返回 True。

*blocking* 设为 False 调用此方法，则不会阻塞。如果调用时锁未被释放，则立即返回 False；否则将锁锁定并返回 True。

浮点型参数 *timeout* 设为正值调用此方法，只要无法获得锁，将最多阻塞 *timeout* 设定的秒数。*timeout* 参数设为 `-1` 时将无限等待。当 *blocking* 为 False 时，*timeout* 指定的值将被忽略。

如果成功获得锁，则返回 True，否则返回 False（例如发生超时）。

### release()

释放锁。这个方法可以在任何线程中调用，不单是获得锁的线程。

当锁被锁定，将它重置为未锁定，并返回。如果其他线程正在等待这个锁解锁而被阻塞，只允许其中一个允许。

在未锁定的锁调用时，会引发 `RuntimeError`。

没有返回值。

### locked()

如果锁被获得（锁定）则返回 True。

## RLock

## Condition

## Semaphore

## Event

这是线程间通信的最简单机制之一：一个线程发出一个事件信号，其他线程等待该事件。

```python
class threading.Event
```

实现事件对象的类。事件对象管理一个内部标识，调用 `set()` 方法可将其设置为 True，调用 `clear()` 方法可将其设置为 False，调用 `wait()` 方法将进入阻塞直到标识为 True。这个标识的初始值为 False。

### is_set()

当且仅当内部标识为 True 时返回 True。

### set()

将内部标识设置为 True。

### clear()

将内部标识设置为 False。

### wait()

```python
wait(timeout=None)
```

阻塞直到内部标识为 True。如果调用时内部标识为 True，则立即返回。否则将阻塞线程，直到调用 `set()` 方法将标识设置为 True 或者发生可选的超时。

当提供了 *timeout* 参数且不为 None 时，它应该是一个浮点数，代表操作的超时时间，以秒为单位。

当且仅当内部标识被设为 True 时此方法将返回 True，不管是在此方法调用之前还是之后。也就是说，它将总是返回 True，除非设定了超时且操作发生了超时。

## Timer

## Barrier
