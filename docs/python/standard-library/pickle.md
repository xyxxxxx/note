# pickle——Python 对象序列化

`pickle` 模块实现了对一个 Python 对象结构的二进制序列化和反序列化。pickle 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 unpickle 是与之相反的操作，会将（来自一个二进制文件或者字节类对象的）字节流转化回一个对象层次结构。在官方文档中，前者称为**封存**，后者称为**解封**。

> 警告：pickle 模块**并不安全**。你只应该对你信任的数据进行 unpickle 操作。
> 
> 构建恶意的 pickle 数据以**在解封时执行任意代码**是可能的。绝对不要对不信任来源的数据和可能被篡改过的数据进行解封。
> 
> 请考虑使用 [hmac](#hmac) 来对数据进行签名，确保数据没有被篡改。
> 
> 在你处理不信任数据时，更安全的序列化格式如 json 可能更为适合。参见 与 json 模块的比较 。

## 模块接口

### dump()

封存对象，并将封存后的对象写入到文件对象。

```shell
$ python
>>> import pickle
>>> data = {
    'a': [1, 2.0, 3, 4+6j],
    'b': ("character string", b"byte string"),
    'c': {None, True, False}
}
>>> with open('data.pickle', 'wb') as f:
    pickle.dump(data, f)
>>> 
$ python
>>> import pickle
>>> with open('data.pickle', 'rb') as f:
    data = pickle.load(f)
>>> data
{'a': [1, 2.0, 3, (4+6j)], 'b': ('character string', b'byte string'), 'c': {False, True, None}}
```

### dumps()

封存对象，并将封存后的对象作为 bytes 对象返回。

### load()

从文件对象读取封存后的对象，重建其中的层次结构并返回。

### loads()

从 bytes 对象读取封存后的对象，重建其中的层次结构并返回。

## 可以封存的对象

下列类型可以被封存：

* `None`、`True`、`False`
* 整数、浮点数、复数
* 字符串、byte、bytearray
* 只包含可封存对象的集合，包括元组、列表、集合和字典
* 定义在模块最外层的函数（使用 `def` 定义，lambda 函数则不可以）
* 定义在模块最外层的内置函数
* 定义在模块最外层的类
* 某些类实例，如果这些类的 `__dict__` 属性值或 `__getstate__()` 函数的返回值可以被封存（详见[封存类实例](#封存类实例)）。

尝试封存不能被封存的对象会抛出 `PicklingError` 异常，异常发生时，可能有部分字节已经被写入指定文件中。尝试封存递归层级很深的对象时，可能会超出最大递归层级限制，此时会抛出 `RecursionError` 异常，可以通过 `sys.setrecursionlimit()` 调整递归层级，不过请谨慎使用这个函数，因为可能会导致解释器崩溃。

需要注意的是，函数（内置函数或用户自定义函数）在被封存时，引用的是函数全名。这意味着只有函数所在的模块名，与函数名会被封存，函数体及其属性不会被封存。因此，在解封的环境中，函数所属的模块必须是可以被导入的，而且模块必须包含这个函数被封存时的名称，否则会抛出异常。

同样地，类也只封存名称，而不会封存类体，所以在解封环境中也有和函数相同的限制。

## 封存类实例