# 正则表达式

## 简易教程

### 元字符，限定符，位置符

| char                                 | quantifiers              | position           |
| ------------------------------------ | ------------------------ | ------------------ |
| `\d` 数字                            | `*` 任意个               | `^` 起始           |
| `\D` 非数字                          | `+` 至少1个              | `$` 结束           |
| `\w` 字母或数字或汉字或下划线        | `?`  0个或1个            | `\b` 单词边界      |
| `\W` 非字母或数字或汉字或下划线      | `{n}` n个                | `\B` 非单词边界    |
| `\s` 任意空白字符, 即`[ \f\n\r\t\v]` | `{min,max}` min至max个   | 单词: 连续的\w子串 |
| `\S` 任意非空白字符                  | `{min,}`       至少min个 |                    |
| `.`   任意字符(除\n)                 | `{,max}`       至多      |                    |
|                                      | `~?` 懒惰匹配后缀        |                    |

### 转义符号

| `\-`       | `\_` | `\,`       | `\.`       |
| ---------- | ---- | ---------- | ---------- |
| `\?`       | `\!` | `\*`       | `\+`       |
| `\^`       | `\$` | `\(`, `\)` | `\[`, `\]` |
| `\{`, `\}` | `\\` |            |            |

### 字符类[]

```
[aeiou]                     # 'a','e','i','o','u'中的任意一个
[0-9]                       # 等同于\d
[0-9a-zA-Z_]                # 1个数字、字母或者下划线
[0-9a-zA-Z_]+               # 1个或多个~
[a-zA-Z\_][0-9a-zA-Z\_]*    # 首字符为字母或下划线,即Python的合法变量名

[^x]                        # 除'x'的任意字符
[^aeiou]                    # 除'a','e','i','o','u'的任意字符
```

### 分枝条件|

#### 局部分枝

```
(P|p)ython                  # 'python' 或 'Python'
3\.(6|7|8)                  # '3.6', '3.7' 或 '3.8'
```

#### 全局分枝

```
0\d{2}-\d{8}|0\d{3}-\d{7}   # '027-87654321' 或 '0717-7654321'
```

#### 可选分枝

```
info(|rmation)              # 'info' 或 'information'
```

### 分组

```
(\d{1,3}\.){3}\d{1,3}           # 简单的IP地址匹配
((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)   # 完整的IP地址匹配

\b(\w+)\b\s+\1\b		          # go go
#(\w+)将\w+捕获至分组1,之后的\1调用捕获内容

\b(?<Word>\w+)\b\s+\k<Word>\b	# 自定义分组名
```

**分组语法**

| **捕获** | `(exp)`        | 匹配exp，并捕获文本到自动命名的组里             |
| -------- | -------------- | ----------------------------------------------- |
|          | `(?<name>exp)` | 匹配exp，并捕获文本到名称为name的组里           |
|          | `(?:exp)`      | 匹配exp，不捕获匹配的文本，也不给此分组分配组号 |
| 零宽断言 |                |                                                 |
|          | `(?<=exp)`     | 匹配前面是exp的位置                             |
|          | `(?=exp)`      | 匹配后面是exp的位置                             |
|          | `(?<!exp)`     | 匹配前面不是exp的位置                           |
|          | `(?!exp)`      | 匹配后面不是exp的位置                           |
| 注释     | `(?#comment)`  |                                                 |

### 零宽断言

零宽表示并不匹配任何字符，断言表示验证条件是否为真。

#### 正向零宽断言

```
# 后条件
\b\w+(?=ing\b)      # 从' reading listening '匹配'read', 'listen'

^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$  # 强密码(必须包含大小写字母和数字的组合,不能使用特殊字符,长度在 8-10 之间)
# 起始位置之后的3个正向零宽断言分别验证包含了数字,小写字母和大写字母

# 前条件
(?<=\bmono)\w+\b	# 从' monorail monopoly '匹配'rail', 'poly'
```

类似于`(?<=A|B|C)`的正向零宽断言可以写为`(?:(?<=A)|(?<=B)|(?<=C))`，例如：

```python

```

#### 负向零宽断言

```
# 后禁止
\d{3}(?!\d)         # 匹配3位数字且之后不能是数字

# 前禁止
(?<![a-z])\d{7}     # 匹配3位数字且之前不能是小写字母 
```

类似于`(?<!A|B|C)`的负向零宽断言可以写为`(?<!A)|(?<!B)|(?<!C)`，例如：

```

```

#### 正向或负向零宽断言(look-around)

```python
>>> re.sub(r'\s+(?=[^\[\(]*\))|(?<=\()\s+', '', 'abcd (  ()e(e w  )f ) gh')
'abcd (()e(ew)f) gh'
```

### 贪婪和懒惰匹配

```python
# *+为贪婪匹配
>>> re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')         # \d+直接匹配到结束
>>> re.match(r'^(\d*)(0*)$', '102300').groups()
('102300', '')

# *,+,?,{n,m}接?以懒惰匹配,即尽可能少匹配
>>> re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')         # \d+?仅匹配'1023',剩余的'00'留给0*
    
```

### 处理选项

```python
IgnoreCase 忽略大小写
```

### 常用正则表达式

```
# 空白行
\n\s*\r

# 中文字符
[\u4e00-\u9fff]

# ip地址
((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

# 国内电话号码
\d{3}-\d{8}|\d{4}-\d{7}

# 强密码(必须包含大小写字母,数字)
^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$

# (http/https) url
https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)
```

## 常用工具

### Python 标准库：re

#### compile()

将正则表达式编译为一个正则表达式对象（正则对象），可以用于匹配。对于需要多次使用的正则表达式，使用`re.compile()`保存这个正则对象以便于复用，可以让程序更加高效。

```python
>>> prog = re.compile(r'^\d{3,4}\-\d{3,8}$')
>>> prog.match('0716-8834387')
<_sre.SRE_Match object at 0x1041b1ac0>
```

#### findall()

对字符串从左到右扫描，找到所有不重复的正则表达式的匹配子串，返回其组成的列表。

```python
>>> re.findall(r'\d{3}', '123456789')
['123', '456', '789']
>>> re.findall(r'\d{3,5}', '123456789')
['12345', '6789']
```

#### finditer()

对字符串从左到右扫描，找到所有不重复的正则表达式的匹配子串，返回一个保存了所有匹配对象的迭代器。

```python
>>> it = re.finditer(r'\d{3}', '123456789')
>>> list(it)
[<re.Match object; span=(0, 3), match='123'>, <re.Match object; span=(3, 6), match='456'>, <re.Match object; span=(6, 9), match='789'>]
```

#### fullmatch()

如果整个字符串匹配正则表达式，就返回一个相应的匹配对象，否则返回`None`。 

```python
>>> re.fullmatch(r'\d{3,5}', '123456789')             # 整个字符串不匹配
>>> re.fullmatch(r'\d{3,10}', '123456789')            # 整个字符串匹配
<re.Match object; span=(0, 9), match='123456789'>
>>> 
>>> if re.fullmatch(r'\d{3,4}\-\d{3,8}', '0716-8834387'):   # 用作判断条件
    print('success')
else:
    print('failure')
...
success
```

#### match()

如果字符串的一个前缀匹配正则表达式，就返回一个相应的匹配对象，否则返回`None`。 

```python
>>> re.match(r'\d{3}', '123456789')
<re.Match object; span=(0, 3), match='123'>          # 前缀匹配
>>> re.match(r'\d{3,5}', '123456789')
<re.Match object; span=(0, 5), match='12345'>        # 尽可能多地匹配
>>> re.match(r'\d{3,5}', 'a123456789')               # 前缀不匹配
>>>
>>> if re.match(r'^\d{3,4}\-\d{3,8}$', '0716-8834387'):   # 用作判断条件
    print('success')
else:
    print('failure')
... 
success
```

#### Match

匹配对象。

##### group()

返回一个或多个组的匹配子串。若参数为组号，则返回对应组的匹配子串；若参数为 `0`，则返回完整的匹配子串；若没有参数，则默认参数为 `0`；若有多个参数，则返回相应结果组成的元组。

```python
>>> m = re.match(r'^(\d{3,4})\-(\d{3,8})$', '0716-8834387')
>>> m.group(1)     # 第1组
'0716'
>>> m.group(2)     # 第2组
'8834387'
>>> m.group(0)     # 完整的匹配子串
'0716-8834387'
>>> m.group()      # 等价于`m.group(0)`
'0716-8834387'
>>> m.group(1, 2)       # 第1组和第2组
('0716', '8834387')
>>> m.group(0, 1, 2)    # 完整的匹配子串,第1组和第2组
('0716-8834387', '0716', '8834387')
```

##### groups()

返回所有组的匹配子串组成的元组。

```python
>>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
>>> m.groups()
('24', '1632')
>>> m = re.match(r"(\d+)\.?(\d+)?", "24")     # 第2组是可选的,因此不一定参与匹配
>>> m.groups()
('24', None)            # 未匹配,返回`None`
```

##### re

返回参与匹配的正则对象。

##### span()

返回组的匹配子串的开始和结束位置的索引组成的二元组，用法与 `start()`, `end()` 相同。

```python
>>> m = re.match(r'^(\d{3,4})\-(\d{3,8})$', '0716-8834387')
>>> m.span(2)
(5, 12)
```

##### start(), end()

返回组的匹配子串的开始/结束位置的索引。若参数为 `0`，则返回完整的匹配子串的开始/结束位置的索引；若没有参数，则默认参数为 `0`。

```python
>>> m = re.match(r'^(\d{3,4})\-(\d{3,8})$', '0716-8834387')
>>> m.start(2)
5
>>> m.end(2)
12
```

##### string

返回参与匹配的字符串。

#### Pattern

编译后的正则表达式对象（正则对象）支持以下方法：`findall()`, `finditer()`, `fullmatch()`, `match()`, `search()`, `split()`, `sub()`。调用这些方法时不再需要传入 `pattern` 参数。

#### search()

扫描整个字符串并找到匹配正则表达式的第一个位置，并返回一个相应的匹配对象；如果没有匹配则返回 `None`。 

```python
>>> re.search(r'\d{3}', '123456789')
<re.Match object; span=(0, 3), match='123'>         # 匹配的第一个位置
>>> re.search(r'\d{3,5}', '123456789')
<re.Match object; span=(0, 5), match='12345'>       # 尽可能多地匹配
>>> re.search(r'\d{3,5}', 'a123456789')
<re.Match object; span=(1, 6), match='12345'>       # 匹配的第一个位置
```

#### split()

使用正则表达式将字符串划分为若干子串，返回其组成的列表。如果正则表达式中捕获到组，则组中的子串也会包含在列表里。

```python
re.split(pattern, string, maxsplit=0, flags=0)
# pattern      正则表达式
# string       要划分的字符串
# maxsplit     最多划分次数
# flags
```

```python
>>> re.split(r'\W+', 'Words, words, words.')        # 从左到右扫描,找到所有不重复的匹配子串并据此划分字符串
['Words', 'words', 'words', '']
>>> re.split(r'(\W+)', 'Words, words, words.')      # 匹配子串也包含在列表里
['Words', ', ', 'words', ', ', 'words', '.', '']
```

#### sub()

对字符串从左到右扫描，找到所有不重复的正则表达式的匹配子串并进行替换；如果没有匹配的子串，则返回原字符串。

```python
re.sub(pattern, repl, string, count=0, flags=0)
# pattern      正则表达式
# repl         替换结果,可以是字符串或函数.若为函数,则会对所有不重复的匹配子串调用此函数;此函数接收一个匹配对象参数,
#              返回一个替换后的字符串
# string       要替换的字符串
# count        最多替换次数.若为`0`,则替换所有的匹配子串
# flags
```

```python
>>> re.sub(r'\d{3}', '0', '123456789')
'000'
>>> re.sub(r'\d{3,5}', '0', '123456789')
'00'
>>> 
>>> re.sub(r'node(s?)', r'Node\1', '111node222nodes333')
'111Node222Nodes333'
```

## 练习

```python
>>> re.search('[\u4e00-\u9fff]', '中文')       # 匹配中文(中日韩统一表意文字)
<re.Match object; span=(0, 1), match='中'>

# 去掉
>>> 
'aa那就4哦撒01加上rw那就嗯'
```
