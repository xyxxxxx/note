{"./":{"url":"./","title":"Introduction","keywords":"","body":"README CS相关学习笔记。 "},"C/notice.html":{"url":"C/notice.html","title":"注意","keywords":"","body":"Details 零长度实参输入的处理 变量是否上溢/下溢 数组是否上溢/下溢 "},"C/runtime-environment-devtool.html":{"url":"C/runtime-environment-devtool.html","title":"运行环境与开发工具","keywords":"","body":""},"C/type-operator-expression.html":{"url":"C/type-operator-expression.html","title":"类型，运算，语句","keywords":"","body":"运算符 算数运算符 + - * / % ++ -- 关系运算符 == != > = 逻辑运算符 && || ! 位运算符 & | ^异或 ~取反 >右移 赋值运算符 = += -= *= /= %= >= &= ^= |= 杂项运算符 sizeof() & * ?: ^ 运算顺序 从左到右 优先级排序，同级别按照结合性 类别 运算符 结合性 后缀 () [] -> . ++ - - 从左到右 一元 ! ~ ++ - - (type)* & sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 > 从左到右 关系 >= 从左到右 相等 == != 从左到右 位与 AND & 从左到右 位异或 XOR ^ 从左到右 位或 OR \\ 从左到右 逻辑与 AND && 从左到右 逻辑或 OR \\ \\ 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=>>= = 从右到左 逗号 , 从左到右 数据类型 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 float 4 字节 1位符号, 8位指数, 23位小数 double 8 字节 1位符号, 11位指数, 52位小数 计算转换 char → int → long → double, float → double 强制转换 (int)/... size_t unsigned int 类型，用来表示参数/数组个数，sizeof 返回值 FILE 存储文件流信息的类型 自定义类型 typedef float real; //使用real表示float类型 typedef int num[100];//声明num为整数数组类型 typedef char *string;//使用string表示字符指针类型 枚举类型 enum month{ Jan, Feb, Mar, ..., Dec};//定义month类型的变量仅能有12个取值,赋值为0,1,...,11 month 特殊语法 # //file inclusion #include //预处理时此语句被替换为头文件内容 //macro substitution #define pi 3.1415926 //将token(pi)替换为text(3.1415926) #define forever for(;;) #define max(A,B) ((A)>(B)?(A):(B)) //带参数的宏 //和函数相比,宏只有替换的功能 //用宏替代函数可以避免函数运行的开支 #define dprint(expr) printf(#expr \" = %g\\n\",expr) //#expr被替换为\"x/y\" #define paste(front,back) front ## back //拼接front和back,即frontback #undef getchar //取消宏定义 //conditional inclusion #if SYSTEM == SYSV #define HDR \"stsv.h\" #elif SYSTEM == BSD #define HDR \"bsd.h\" #elif SYSTEM == MSDOS #define HDR \"msdos.h\" #else #define HDR \"default.h\" #endif #include HDR #ifndef HDR //如果未定义宏 #define HDR /*contents of hdr.h*/ #endif const //const变量只能在初始化时被赋值 const double e = 2.71828182845905; const char msg[] = \"warning:\"; //参数声明const表示函数不会更改之 int strlen(const char[]); extern https://blog.csdn.net/xingjiarong/article/details/47656339 //extern关键字声明外部变量 //如果外部变量在同一源文件的首部声明，则省略extern //如果外部变量在另一源文件声明 static & automatic #include void test() { auto a = 0; //定义自动存储类型变量 static int b = 3; //定义静态存储类型变量 a++; b++; printf(\"%d\\n\", a); //输出a printf(\"%d\\n\", b); //输出b } int main() { int i; for (i = 0; i "},"C/control-flow.html":{"url":"C/control-flow.html","title":"流程控制","keywords":"","body":"流程控制 条件结构 if (条件) {语句组} ----- if (条件) {语句组1} else {语句组2} ----- switch (表达式)/* int or char*/ {case constant1: sentence1 break; case constant2: sentence2 break; ...... default: sentence } 循环结构 while (condition) { sentence; } ----- do { sentence; } while(condition) ----- for(初值;条件;增量) /*适用于变量范围确定*/ ----- break 跳出循环 continue 立即进行下一次循环 "},"C/function.html":{"url":"C/function.html","title":"函数","keywords":"","body":"函数 定义函数 int isprime(int n) /*函数的返回值类型，函数名，参数类型和名*/ { int i; for(i=2;i=10) {printf(\"%d\",n%10); int_turn(n/10); } else printf(\"%d\",n); } "},"C/compilation.html":{"url":"C/compilation.html","title":"编译过程","keywords":"","body":"编译过程 Preprocessing gcc -E hello.c -o hello.i 将#define语句宏进行替换 处理#if,#ifdef等条件编译指令 将#include语句替换为头文件内容 删除所有注释 添加行号和文件标识 保留#pragma编译器指令 compilation gcc -S hello.c -o hello.s 词法分析 语法分析 语义分析 生成汇编代码 assembly gcc -c hello.c -o hello.o link gcc hello.c -o hello.exe "},"C/pointer.html":{"url":"C/pointer.html","title":"指针","keywords":"","body":"指针 指针的类型 int *pa; /*定义指针*/ pa=&a; //or int *pa=&a; ----- int a[5]={1,2,3,4,5}; int *pa=a/*指针指向数组*/ a[i]==*(pa+i)==*(a+i);/*pa和a都是数组a的起始地址即a[0],+i表示其后i个地址,*表示取该地址的存储数据*/ ----- int a[5]={1,2,3,4,5}; int *p1, *p2; p1=&a[0]; p2=&a[4]; //p2-p1==4 ----- char *a=\"Hello world\";/*字符指针变量*/ /*相当于有s[]=\"Hello world\",然后a指向字符串s的起始位置*/ ----- ----- ----- int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; /*指针指向二维数组*/ /* a,a[0],&a[0][0],*a(==a[0])都表示a的起始地址*/ /* a+i,a[i],&a[i][0],*(a+i)表示a第i+1行的起始地址*/ /* a[i]+j是a[i]的第j个元素地址,即&a[i][j]*/ int *p; p=a; ----- int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; /*行指针*/ int (*p)[4]; /*4为长度*/ /* p=a时,其指向一维数组a[0]*/ /* p+i指向数组a[i],因此*(p+i)+j即a[i]+j */ ----- ----- ----- /*指向函数的指针*/ --- float *search(float (*pointer)[4],int n) /*指针型函数,返回一个地址*/ ----- char name[5][10]={\"Alice\",\"Bob\",\"Cindy\",\"Dave\",\"Elizabeth\"}; char *p[5]={name[0],name[1],name[2],name[3],name[4]};/*指针数组,由5个指针变量组成*/ ----- int *p1,**p2;/*二级指针,p2保存p1的地址*/ 指针的举例说明 int x=1; char a=\"A\";// int y[3]={1,2,3}; char b[5]=\"Alice\";//数组 int z[3][3]={1,2,3,4,5,6,7,8,9}; char c[5][10]={\"Alice\",\"Bob\",\"Cindy\",\"Dave\",\"Elizabeth\"};//二维数组 int *px=&x; char *pa=&a;// int *py=y=&y[0]; char *pb=b=&b[0];//数组的指针 int *pz=z=z[0]=&z[0][0]=*z;//*z=z[0] char *pc=c=c[0]=&c[0][0];//二维数组的指针 int (*pzl)[3]=z; char (*pcl)[10]=c; //二维数组的行指针 int *pzm[3]={z[0],z[1],z[2]}; char *pcm[5]={c[0],c[1],c[2],c[3],c[4]};//二维数组的指针数组 int **pp=&pzm//二级指针 | address | name | value | | 0000 | x | 1 | | 0010 | a | A | | 0100 | y[0] | 1 | | 0101 | y[1] | 2 | | 0102 | y[2] | 3 | | 0200 | b[0] | A | | 0201 | b[1] | l | | 0202 | b[2] | i | | 0203 | b[3] | c | | 0204 | b[4] | e | | 0205 | b[5] | \\0 | | 1000 | z[0][0] | 1 | | 1001 | z[0][1] | 2 | | 1002 | z[0][2] | 3 | | 1003 | z[1][0] | 4 | | 1004 | z[1][1] | 5 | | 1005 | z[1][2] | 6 | | 1006 | z[2][0] | 7 | | 1007 | z[2][1] | 8 | | 1008 | z[2][2] | 9 | | 2000 | c[0][0] | A | | 2001 | c[0][1] | l | | 2002 | c[0][2] | i | | 2003 | c[0][3] | c | | 2004 | c[0][4] | e | | 2005 | c[0][5] | \\0 | ... | 2009 | c[0][9] | \\0 | | 2010 | c[1][0] | B | ... | 2020 | c[2][0] | C | ... | 2030 | c[3][0] | D | ... | 2040 | c[4][0] | E | ... | 2049 | c[0][9] | \\0 | | 8000 | px | 0000 | | 8010 | pa | 0010 | | 8100 | py | 0100 | | | py+1 | 0101 | | 8200 | pb | 0200 | | 9000 | pz | 1000 | | | pz+1 | 1001 | | 9100 | pc | 2000 | | | pc+1 | 2001 | | 9200 | pzl | 1000~1002 | | | pzl+1 | 1003~1005 | | | *(pzl+1)+1 | 1004 |// *(pzm+1)=z[1] | 9300 | pcl | 2000~2009 | | | pcl+1 | 2010~2019 | | | *(pcl+1)+1 | 2011 | | 9400 | pzm[0] | 1000 | | 9401 | pzm[1] | 1003 | | 9402 | pzm[2] | 1006 | | 9500 | pcm[0] | 2000 | | 9501 | pcm[1] | 2010 | | 9502 | pcm[2] | 2020 | | 9503 | pcm[3] | 2030 | | 9504 | pcm[4] | 2040 | | 10000 | pp | 9400 | | | pp+1 | 9401 | "},"C/array-string.html":{"url":"C/array-string.html","title":"数组，字符串","keywords":"","body":"数组 定义数组m[i]有元素m[0],m[1],...,m[i-1] int m1[5]={1,2,3,4,5}; int m2[ ]={1,2,3,4,5,6}; int m3[5]={0}; int m4; /*未赋值的元素会成为随机数*/ char ch[6]=\"CHINA\"; /*会补足一位/0*/ char ch[6]=\"CH\"; /*后4位会补足/0*/ int a[2][3]={{1,2,3},{4,5,6}}; int a[2][3]={1,2,3,4,5,6}; int a[][3]={1,2,3,4,5,6}; /*只可以省略行下标*/ int a[2][3]={{1,2},{4}};/*会补足0*/ a[i]+j==&a[i][j];/*a[i]+j表示i行j列的地址 */ *(a[i]+j)==a[i][j];/* *()表示取地址的内容 */ "},"C/structure.html":{"url":"C/structure.html","title":"结构","keywords":"","body":"结构 结构体 struct date //定义日期结构体由3个int字段组成 { int year, month, day; }today; //变量today包括3个int字段，占用连续的3*2字节 struct student //结构体的嵌套 { int stuno; char name[20]; struct date birthday; }; struct student stu1={2001001,\"Zhang San\",1990,1,1};//结构体变量的初始化 stu1.num=2001001; //数据访问 stu1.birthday.year=1990; struct student stu[]={{},{},...,{}}; //结构体数组的初始化 stu[1].num=2001001; //数据访问 struct date *p, date[]={{2001,1,1},{2002,2,2},{2003,3,3}}; //结构体指针 p=date; //即p=date[0] //p->year==(*p).year==2001 表示指针p所在结构变量的year字段，或者*p取所在结构变量 //(++p)->month==2 由于p已经被定义为date结构的指针,结构变量将被视作一个整体,++p会从第一个结构变量的起始地址跳到第二个的起始地址, //++p->day 将第二个结构变量的day字段+1,因为->的运算优先级高于++ sizeof(stu1); //返回结构变量的字节数 #define NKEYS (sizeof(stu)/sizeof(stu[0])) //结构数组的规模 联合 union u { char u1; int u2; long u3; }; //同一内存段中可存放几种类型的变量，变量会覆盖存放 u.u1 //引用方式 &u=&u.u1=&u.u2 //联合仅有一地址 //联合不能初始化、赋值，不能作为函数参数，但可以使用指针访问 链表 //创建单向链表 struct node //1.定义结点结构 { char name[20],addr[20],tel[15]; struct node *link //包含同结构指针 }; typedef struct node NODE;//结点结构重命名 NODE *head;//2.表头指针head head=(NODE *)malloc(sizeof(NODE));////3.表头结点 开辟新存储区,强制转换malloc的返回值类型为NODE指针 head->link=NULL; NODE *p;//4.添加数据节点 p=(NODE *)malloc(sizeof(NODE)); gets(p->name);gets(p->addr);gets(p->tel); p->link=NULL; head->link=p; NODE *p;//5.插入数据节点 p=(NODE *)malloc(sizeof(NODE)); gets(p->name);gets(p->addr);gets(p->tel); p->link=head->link; head.link->=p; ----- void output(NODE *head) //创建函数访问链表数据 { NODE *p; p=head->link; while (p!=NULL) { puts(p->name); p=p->link; } } void insert(NODE *head, NODE *p, int i)//第i个位置插入节点p { NODE *q; int n=0; for (q=head;nlink!=NULL;++n) q=q->link; p->link=q->link; q->link=p; } void delete(NODE *head, int i) //删除第i个节点 { NODE *q, *p;//p指针指向被删结点 int n; for (n=0,q=head;nlink!=NULL;++n) q=q->link; p=q->link; q->link=p->link; free(p);//释放被删除结点内存 } "},"C/io.html":{"url":"C/io.html","title":"IO","keywords":"","body":"IO 流 //标准输入流 stdin=0 对应文件standard input 通常连接键盘 //标准输出流 stdout=1 对应文件standard output 通常连接显示器 //标准错误流 stderr=2 对应文件standard error 通常连接显示器 //文件流 FILE *fopen(char *filename, char *mode); //return NULL if failed int fclose(FILE *fp); //return 0 if succeeded, FILE * fp; fp = fopen (\"file.txt\", \"w+\"); r 已有文件，只读 r+ 已有文件，读写 w 新文件，只写 w+ 新文件，读写 a 已有或新文件，追加 a+ 已有或新文件，读追加 ～b 字节文件(而非文本文件) //fflush将输出流的缓冲区的剩余数据全部写出 //remove删除指定文件 //rename重命名指定文件 //tmpfile返回一个临时文件的流 IO function printf, scanf //printf(\"\", ); //printf发送格式化输出到标准输出stdout //scanf从标准输入stdin读取格式化输入 //scanf(\"%[a-z]\",&str);读取字符集合 #include int main() { float f; printf(\"Enter a number: \"); scanf(\"%f\",&f); //args必须传入地址/指针 printf(\"Value = %f\", f); return 0; } //fprintf发送格式化字符到流stream中 //fscanf从流stream读取格式化输入 int fprintf(FILE *stream, const char *format, ...) int fscanf(FILE *stream, const char *format, ...) %d int %3d int with 3 char wide %f double %6.2f double with 6 char wide with 2 after decimal %s str %c char %o oct %x hex \\n 换行 \\t Tab \\r 回车（回到行首） \\b 退格 空格 \\\\ \\ getchar, putchar //getchar从标准输入stdin获取1个字符 //putchar将1个字符写入标准输出stdout #include int main( ) { int c; //int类型以接收EOF printf( \"Enter a value :\"); c = getchar( ); //get 1 char printf( \"\\nYou entered: \"); putchar( c ); //put 1 char printf( \"\\n\"); return 0; } int getc(FILE *fp) //return EOF if end or err int putc(int c, FILE *fp) //return EOF if err gets, puts //gets从标准输入stdin读入一行并存储在str指向的字符串 //puts将一个字符串写入标准输出stdout #include int main( ) { char str[100]; printf( \"Enter a value :\"); gets( str ); //read 1 line from stdin to buffer printf( \"\\nYou entered: \"); puts( str ); //write buffer to stdout return 0; } //fgets从流stream中读入n-1个字符(或者读至行末)并存储到buffer //fputs将字符串写入流stream中并换行 char *fgets( char *buf, int n, FILE *fp ); // int fputs(char *s, FILE *fp); read, write //fread从流stream中读取数据到指针指向的数组 //fwrite将指针指向数组的数据写入流stream size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) #include #include int main() { FILE *fp; char c[] = \"This is runoob\"; char buffer[20]; /* 打开文件用于读写 */ fp = fopen(\"file.txt\", \"w+\"); /* 写入数据到文件 */ fwrite(c, strlen(c) + 1, 1, fp); /* 查找文件的开头 */ fseek(fp, 0, SEEK_SET); /* 读取并显示数据 */ fread(buffer, strlen(c)+1, 1, fp); printf(\"%s\\n\", buffer); fclose(fp); return(0); } positioning //fseek使位置指针从设定位置偏移 #include int main () { FILE *fp; fp = fopen(\"file.txt\",\"w+\"); fputs(\"This is runoob.com\", fp); fseek( fp, 7, SEEK_SET ); //SEEK_SET 文件开头 SEEK_CUR 指针当前位置 SEEK_END 文件末尾 fputs(\" C Programming Langauge\", fp); fclose(fp); return(0); } //rewind(倒带)使位置指针回到文件头 //ftell返回指针当前位置 error //feof检测流是否已设定文件结束标识符EOF，返回0表示未设定 if( feof(fp) ){ break ; } //ferror检测流是否已设定错误标识，返回0表示未设定 if( ferror(fp) ) { printf(\"读取文件：file.txt 时发生错误\\n\"); } "},"C/error-handling.html":{"url":"C/error-handling.html","title":"错误处理","keywords":"","body":"错误处理 //errno表示错误代码，int类型 //strerror通过参数errno返回错误信息 stderror(errno) //perror输出参数字符串和当前错误信息到标准错误输出stderr perror(const char *s) //等价于 fprintf(stderr,\"%s: %s\\n\",s,err_msg) #define EPERM 1 /* Operation not permitted */ 　　#define ENOENT 2 /* No such file or directory */ 　　#define ESRCH 3 /* No such process */ 　　#define EINTR 4 /* Interrupted system call */ 　　#define EIO 5 /* I/O error */ 　　#define ENXIO 6 /* No such device or address */ 　　#define E2BIG 7 /* Argument list too long */ 　　#define ENOEXEC 8 /* Exec format error */ 　　#define EBADF 9 /* Bad file number */ 　　#define ECHILD 10 /* No child processes */ 　　#define EAGAIN 11 /* Try again */ 　　#define ENOMEM 12 /* Out of memory */ 　　#define EACCES 13 /* Permission denied */ 　　#define EFAULT 14 /* Bad address */ 　　#define ENOTBLK 15 /* Block device required */ 　　#define EBUSY 16 /* Device or resource busy */ 　　#define EEXIST 17 /* File exists */ 　　#define EXDEV 18 /* Cross-device link */ 　　#define ENODEV 19 /* No such device */ 　　#define ENOTDIR 20 /* Not a directory */ 　　#define EISDIR 21 /* Is a directory */ 　　#define EINVAL 22 /* Invalid argument */ 　　#define ENFILE 23 /* File table overflow */ 　　#define EMFILE 24 /* Too many open files */ 　　#define ENOTTY 25 /* Not a typewriter */ 　　#define ETXTBSY 26 /* Text file busy */ 　　#define EFBIG 27 /* File too large */ 　　#define ENOSPC 28 /* No space left on device */ 　　#define ESPIPE 29 /* Illegal seek */ 　　#define EROFS 30 /* Read-only file system */ #include #include #include extern int errno ; //声明外部变量错误代码errno int main () { FILE * pf; int errnum; pf = fopen (\"unexist.txt\", \"rb\"); if (pf == NULL) { errnum = errno; fprintf(stderr, \"错误号: %d\\n\", errno); perror(\"通过 perror 输出错误\"); fprintf(stderr, \"打开文件错误: %s\\n\", strerror( errnum )); } else { fclose (pf); } return 0; } "},"C/file-management.html":{"url":"C/file-management.html","title":"文件管理","keywords":"","body":"文件管理 unistd.h包含了Unix的系统调用的封装，unistd即unix std的含义。 #include //for func that returns int, return 0 if ok, -1 if err //dir char *getcwd(char *buf, size_t size); // 获取当前目录的绝对路径并存储到buf中,参数size为buf的长度 int chdir(const char *path); // 将path设定为当前目录 int rmdir(const char *path); // 将path目录删除 //access int access(const char *, int); // 权限检测 //R_OK, W_OK, X_OK, F_OK //#include //#include int chmod(const char *path, mode_t mode); // 权限修改, //S_IRUSR S_IWUSR S_IXUSR S_IRWXU //S_IRGRP S_IWGRP S_IXGRP S_IRWXG //S_IROTH S_IWOTH S_IXOTH S_IRWXO //rw ssize_t read(int fd, void *buff, size_t n); // 从文件描述符(流)fd读取n个字节写入字符数组buff的前n个索引 ssize_t write(int fd, void *buff, size_t n); // 将字符数组buff的前n个索引(字节)写入文件描述符(流)fd dirent.h #include #include #include int main() { DIR * dir; //目录流结构体 struct dirent * ptr; int i; dir = opendir(\"/etc/rc.d\"); //根据路径打开目录,返回指向目录结构变量的指针 while((ptr = readdir(dir)) != NULL) //读取目录流,返回dirent结构变量 { printf(\"d_name : %s\\n\", ptr->d_name); } closedir(dir); return 0; } struct dirent //文件信息结构体 { #ifndef __USE_FILE_OFFSET64 __ino_t d_ino; //i节点号 __off_t d_off; //在目录文件中的偏移 #else __ino64_t d_ino; __off64_t d_off; #endif unsigned short int d_reclen; //文件长度 unsigned char d_type; //文件类型 char d_name[256]; //文件名 }; "},"C/memory-management.html":{"url":"C/memory-management.html","title":"内存管理","keywords":"","body":"内存管理 void *calloc(int num, int size); //void * 表示指向未确定类型的指针,赋值时需要强制转型zhuanxing //动态分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0 void *malloc(size_t n); //动态分配一块n字节大小的未初始化的内存空间，返回指向它的指针 void *realloc(void *address, int newsize); //重新分配内存，把内存块扩展到 newsize。 void free(void *address); //释放 address 所指向的内存块,释放的是动态分配的内存空间 #include #include #include int main() { char name[100]; //given length str char *description; //uncertain length str strcpy(name, \"Zara Ali\"); description = (char *)malloc( 30 * sizeof(char) ); //allocate memory dynamically if( description == NULL ) //allocation failed { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcpy( description, \"Zara ali a DPS student.\"); } description = (char *) realloc( description, 100 * sizeof(char) ); if( description == NULL ) { fprintf(stderr, \"Error - unable to allocate required memory\\n\"); } else { strcat( description, \"She is in class 10th\"); } printf(\"Name = %s\\n\", name ); printf(\"Description: %s\\n\", description ); free(description); //free memory } "},"C/network-programming.html":{"url":"C/network-programming.html","title":"网络编程","keywords":"","body":"C network programming [toc] Socket编程简介 socket地址结构 IPv4 socket地址结构——sockaddr_in struct sockaddr_in // POSIX定义 { // uint8_t sin_len // 此结构体长度(16) sa_family_t sin_family // 地址族 in_port_t sin_port; // Port number struct in_addr sin_addr; // Internet address char sin_zero[8]; // unused, 总是将其置0 }; typedef unsigned short int sa_family_t; //地址族类型,即16位无符号整数 typedef uint16_t in_port_t; //端口号类型,即16位无符号整数 struct in_addr //早期in_addr结构曾为多种结构的union { in_addr_t s_addr; }; typedef uint32_t in_addr_t; //internet地址类型,即32位无符号整数 /*******************************************/ serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); //inet_addr()将IP地址字符串转换为in_addr_t类型 serv_addr.sin_port = htons(1234); //htons()将主机字节序转换为网络字节序,即从小端模式转换为大端模式 //例如端口18 在x86 CPU上实际存储为1200,而在报文中为0012 通用socket地址结构 struct sockaddr { // uint8_t sa_len sa_family_t sa_family // 地址族 char sa_data[14]; // Address data }; socket函数将指向该通用地址结构的指针作为参数之一，如 int bind(int,struct sockaddr *, socklen_t) 因此指向特定协议族的socket地址结构都必须强制转型为通用地址结构的指针 IPv6 socket地址结构——sockaddr_in6 struct sockaddr_in6 { // uint8_t sin6_len; // 此结构体长度(28) sa_family_t sin6_family // 地址族 in_port_t sin6_port; // Port number uint32_t sin6_flowinfo; // 低位20 bit flow label, 高位12 bit保留 struct in6_addr sin6_addr; // Internet address uint32_t sin6_scope_id; // 标记地址的范围 } 新通用socket地址结构 struct sockaddr_storage { // uint8_t ss_len; sa_family_t ss_family; char ss_padding[118]; uint32_t ss_align; } //sockaddr_storage能满足最苛刻的对齐要求 //sockaddr_storage足够大以能够容纳任何地址结构 socket地址结构比较 由于Unix域结构和数据链路结构是可变长度的，因此除了传递地址结构的指针给套接字函数，也需要传递该地址结构的长度。 socket函数 bind,connet,sendto从进程到内核传递地址结构，如 connect(sockfd, (struct sockaddr *)&serv, sizeof(serv)); accept,recvfrom,getsockname,getpeername从内核到进程传递地址结构，如 struct sockaddr_un cli; socklen_t len; len-sizeof(sli); getpeername(unixfd,(struct sockaddr *)&cli, &len); 传递地址结构长度的指针的原因是，对于可变长度的结构，内核会修改长度为实际长度 字节排序函数 考虑一个16位整数存储在2个字节中，内存中 socket socket是应用层进入传输层的接口，我们使用socket编写使用TCP或UDP协议的网络应用程序。 int socket (int __domain, int __type, int __protocol) /* 参数domain指通信域/地址族(即IPv4,IPv6,...) PF_INET/AF_INET IPv4协议 PF_UNIX/PF_LOCAL/AF_UNIX/AF_LOCAL 进程通信协议 参数type指socket的类型 SOCK_STREAM 可靠的双向的有连接流,即TCP SOCK_DGRAM 不可靠的无连接的报文,即UDP SOCK_SEQPACKET 有序的可靠的双向的有连接的传输 参数protocol通常置0,自动选择type支持的协议 返回一个小整数描述符,失败则返回负数 */ 参考https://zhuanlan.zhihu.com/p/24916785 "},"C/lib.html":{"url":"C/lib.html","title":"库","keywords":"","body":"库 参见IO 参见内存管理 atof() //str2double atoi() //str2int atol() //str2long rand() //返回伪随机数0～RAND_MAX srand(seed)//使用非负整数作为种子 res=div(numer,denom) //整数带余除法 printf(\"商=%d\\n\",res.quot); printf(\"余数=%d\\n\",res.rem); abs() //返回绝对值 system() //将字符串交由环境(shell)去执行 abort() //程序异常终止 exit(status) //程序终止,status=0正常终止,=-1因错误而终止 //exit亦会调用fclose关闭所有文件指针并flush strcpy(str1,str2) /*str1用str2赋值*/ strcat(str1,str2) //字符串拼接 strcmp(str1,str2) /*字符串比较*/ strchr(cs,c) //查找cs中c首次出现的位置，返回指向该位置的指针 strlen(str) /*字符串长度*/ memcpy(str1, str2, n) //复制str2(指针位置)的前n个字符到str1(指针位置) memmove(str1, str2, n) memset(str, c, n) //复制字符c到str指向的字符串的前n个字符,返回str memcmp(str1, str2, n) //比较str1和str2的前n个字符 memchr(str, c, n) //查找c在str的前n个字符中首次出现的位置 //判定变量类型 //获取可变个数的参数 #include #include int sum(int, ...); int main(void) { printf(\"10、20 和 30 的和 = %d\\n\", sum(3, 10, 20, 30) ); printf(\"4、20、25 和 30 的和 = %d\\n\", sum(4, 4, 20, 25, 30) ); return 0; } int sum(int num_args, ...) { int val = 0; va_list ap; int i; va_start(ap, num_args); //初始化指针ap for(i = 0; i "},"C/makefile.html":{"url":"C/makefile.html","title":"Makefile","keywords":"","body":"Format rule : [Tab] target //target chain result.txt: source.txt cp source.txt result.txt source.txt: echo \"new source\" > source.txt all: target1 target2 target3 commands //replace Tab .RECIPEPREFIX = > all: >echo \"hello\" var-lost: export foo=bar //2 shell echo \"foo=[ $foo]\" var-kept: export foo=bar; echo \"foo=[$ foo]\" //1 shell Grammar comment # comment @# comment not printed @echo \"hello\" match //wildcard *.c ?????.c //pattern matching %.o:%.c // file1.o:file1.c, file2.o:file2.c, ... custom var txt = Hello test: @echo $(txt) environment var test: @echo $$HOME implicit var $(CC) //current compiler $(MAKE) //current Make tool automatic var $@ //current target a.txt: touch $@ $(@D) $(@F) //current target dir & name $structure ifeq ($(CC),gcc) libs=$(libs_for_gcc) else libs=$(normal_libs) endif LIST = one two three all: for i in $(LIST); do echo $(i); done??? function srcfiles := $(shell echo src/{00..99}.txt) "},"C++/runtime-environment-devtool.html":{"url":"C++/runtime-environment-devtool.html","title":"运行环境与开发工具","keywords":"","body":""},"Java/runtime-environment-devtool.html":{"url":"Java/runtime-environment-devtool.html","title":"运行环境与开发工具","keywords":"","body":""},"Java/jvm.html":{"url":"Java/jvm.html","title":"JVM","keywords":"","body":""},"Python/runtime-environment-devtool.html":{"url":"Python/runtime-environment-devtool.html","title":"运行环境与开发工具","keywords":"","body":""},"Go/runtime-environment-devtool.html":{"url":"Go/runtime-environment-devtool.html","title":"运行环境与开发工具","keywords":"","body":""},"Linux/common-command.html":{"url":"Linux/common-command.html","title":"常用命令","keywords":"","body":"[toc] info whatis info //detailed info man //manual which //dir whereis files mv //rename mv //move mv //move or rename rm rm -r //delete dir cp [] //copy file cp -r //copy dir //read more -num //show -num lines once //space to pgdn, q to quit, more +5 //read from line 5 tail -5 //read last 5 lines tail +5 //read from line 5 tail -f //read updates //write cat -n //read txt with line numbers cat -n > //read & write cat -n >> //read & add //create touch //create new empty file //compare diff [] //compare files //clear :> //clear file contents files op //sort file contents by line sort [] //sort by ASCII -r reverse -n by value //link ln -s //symbolic link, like .lnk in Windows ln //hard link, means multiple names of single file //compress tar -cvf //package tar -zcvf //package & compress tar -xvf tar -zxvf [-C ] //decompress dir cd //home cd / //root cd ~ //home cd - //last dir cd //switch dir cd .. // pwd //current dir mkdir //create dir rmdir //delete dir rm -rf //delete non-empty dir ls //list every file ls -lrt //list with info ls -lrt s* //list matching certain name ls -a //list hidden //search file in disk find [] //find file find -name \"*.c\" //by name find -mtime -20 //revised in 20d find -ctime +20 //created before 20d find -type f //type f:normal find -size +100c //size > 100 Bytes, c,k,M find / -type f -size 0 -exec ls -l {} \\; //find every size 0 normal file in disk, show path text //search text egrep [-A1 -B1] //search in file/dir by str egrep //search in file/dir by regular expression logic // && command1 succeed, then command2 cp sql.txt sql.bak.txt && cat sql.bak.txt // || command1 fail, then command2 ls /proc && echo success || echo failed // (;) // | command1 output as command2 input ls -l /etc | more echo \"Hello World\" | cat > hello.txt ps -ef | grep Shell echo //output str clear //clear shell exit //exit shell //xargs cat test.txt | xargs //output single line cat test.txt | xargs -n3 //output by every line 3 words echo \"nameXnameXnameXname\" | xargs -dX //output by splitting by X net hostname //show hostname //revise at /etc/sysconfig/network ifconfig //ipconfig //revise at /etc/sysconfig/network-scripts/ifcfg- nmcli c reload //network restart system management sudo //run as root sudo -u //run as user ps -ef //show all processes ps -aux top //show real-time processes top -d 2 //update every 2s top -p //show designated process kill //kill process kill -9 //kill process compulsorily date //print current time shutdown reboot system setting //redhat package manager rpm -a //show packages rpm -qa | grep //search package with name rpm -e --nodeps //uninstall package //environment variable export -p //show environment variables export var=10 //define environment variable, assign access - --- --- --- d = dir l = link - = file - --- --- --- xxx = access of current User r = read w = write x = execute - --- --- --- xxx = access of current user Group - --- --- --- xxx = access of Other user group chmod u=rwx,g=rwx,o=rwx chmod 777 gcc gcc -E hello.c -o hello.i //Preprocess gcc -S hello.c -o hello.s //Compile gcc -c hello.c -o hello.o //Assemble gcc hello.c -o hello.exe //Link "},"database/MySQL/crud.html":{"url":"database/MySQL/crud.html","title":"CRUD","keywords":"","body":""},"DSA/algorithm/divide-and-conquer.html":{"url":"DSA/algorithm/divide-and-conquer.html","title":"分而治之","keywords":"","body":""},"DSA/algorithm/dp.html":{"url":"DSA/algorithm/dp.html","title":"动态规划","keywords":"","body":""},"DSA/algorithm/greedy-algorithm.html":{"url":"DSA/algorithm/greedy-algorithm.html","title":"贪心算法","keywords":"","body":""},"DSA/algorithm/backtracking.html":{"url":"DSA/algorithm/backtracking.html","title":"回溯算法","keywords":"","body":""},"DSA/algorithm/other.html":{"url":"DSA/algorithm/other.html","title":"其它","keywords":"","body":""},"DSA/data-structure/array-linked-list.html":{"url":"DSA/data-structure/array-linked-list.html","title":"数组，链表","keywords":"","body":""},"DSA/data-structure/stack-queue.html":{"url":"DSA/data-structure/stack-queue.html","title":"栈，队列","keywords":"","body":""},"DSA/data-structure/binary-search-tree.html":{"url":"DSA/data-structure/binary-search-tree.html","title":"二叉搜索树","keywords":"","body":""},"DSA/data-structure/heap.html":{"url":"DSA/data-structure/heap.html","title":"堆","keywords":"","body":""},"DSA/data-structure/hash-table.html":{"url":"DSA/data-structure/hash-table.html","title":"散列表","keywords":"","body":""},"DSA/data-structure/graph.html":{"url":"DSA/data-structure/graph.html","title":"图","keywords":"","body":""},"DSA/leetcode-example.html":{"url":"DSA/leetcode-example.html","title":"leetcode例题","keywords":"","body":""},"OS/process.html":{"url":"OS/process.html","title":"进程","keywords":"","body":""},"OS/memory.html":{"url":"OS/memory.html","title":"内存","keywords":"","body":""},"OS/file-system.html":{"url":"OS/file-system.html","title":"文件系统","keywords":"","body":""},"OS/io.html":{"url":"OS/io.html","title":"IO","keywords":"","body":""},"other/git.html":{"url":"other/git.html","title":"Git","keywords":"","body":""},"other/gitbook.html":{"url":"other/gitbook.html","title":"Gitbook","keywords":"","body":""},"other/json.html":{"url":"other/json.html","title":"json","keywords":"","body":""},"other/latex.html":{"url":"other/latex.html","title":"LaTeX","keywords":"","body":""},"other/markdown.html":{"url":"other/markdown.html","title":"Markdown","keywords":"","body":""},"other/regular-expression.html":{"url":"other/regular-expression.html","title":"正则表达式","keywords":"","body":""},"other/xml.html":{"url":"other/xml.html","title":"XML","keywords":"","body":""}}