现代计算机存储和处理的信息以二值信号表示。当我们把位组合在一起，再加上某种**解释（interpretation）**，即赋予不同的可能位模式以含义，就能够表示任何有限集合的元素。

我们将研究三种最重要的数字表示：**无符号（unsigned）**编码基于传统的二进制表示法，表示大于等于0的数字；**补码（two’s-complement）**编码是表示有符号整数的最常见的方式；**浮点数（floating-point）**编码是表示实数的科学计数法的以2为基数的版本。计算机用不同的表示方法实现算术运算。

计算机的表示法用有限数量的位来对应一个数字编码，因此当结果太大以至于不能表示时，某些运算就会**溢出（overflow）**。一处会导致令人吃惊的后果。

浮点运算有完全不同的数学属性。浮点运算是不可结合的，在大多数机器上，C表达式`(3.14+1e20)-1e20`求得的值会是0.0，而`3.14+(1e20-1e20)`求得的值会是3.14。整数运算和浮点运算的不同的数学属性来源于它们处理数字表示有限性的方式不同——整数的表示虽然只能编码一个相对较小的数值范围。但是这种表示是精确的；浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。

通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了解这种属性是非常重要的。此外，大量计算机的安全漏洞都是由于计算机运算的微妙细节引发的。





# 信息存储

## 十六进制表示法

**十六进制（hexadecimal）**

在C语言中，以0x或0X开头的数字常量被认为是十六进制的值。字符A-F可以是大写，小写，或大小写混合，比如`0xFa1D37b`。

进制转换略



## 字数据大小

每台计算机都有一个**字长（word size）**，指明指针数据的标称大小（nominal size）。由于虚拟地址以字来编码，所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小。对于字长为w位的机器而言，虚拟地址的范围是 $0\sim2^w-1$，程序最多访问$2^w$个字节。32位字长的虚拟地址空间为4GB，64位字长的虚拟地址空间为16EB。大多数64位机器也可以运行32位机器编译的程序。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cxgjio5njyuiognwrj.PNG)

为了避免由于依赖典型大小和不同编译器设置带来的奇怪行为，ISO C99引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化，其中就有数据类型`int32_t`和`int64_t`，它们分别为4个字节和8个字节。

大部分数据类型都编码为有符号数值，除非有前缀关键字`unsigned`或对确定大小的数据类型使用了特定的无符号声明。数据类型`char`是一个例外。尽管大多数编译器和机器将它们视为有符号数，但C标准不保证这一点。

程序员应力图使他们的程序在不同的机器和编译器上可移植，可移植的一个方面就是使程序对不同数据类型的确切大小不敏感。从1980年左右到2010年左右，32位机器和32位程序是主流的组合，许多程序的编写都假设为32位程序的字节分配。随着64位机器的普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就会显现出来成为错误。例如许多程序员假设一个声明为`int`类型的程序对象能被用来存储一个指针，这在大多数32位的机器上能正常工作，但在一台64位的机器上却会出现问题。



## 寻址和字节顺序

对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为`int`的变量`x`的地址为`0x100`，也就是说地址表达式`&x`的值为`0x100`。那么`x`的4个字节将被存储在内存的`0x100`，`0x101`，`0x102`和`0x103`位置。

排列表示一个对象的字节有两个通用的规则。某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象，而另一些机器从最高有效字节到最低有效字节的顺序存储对象。前一种规则称为**小端法（little endian）**，后一种规则称为**大端法（big endian）**。

假设变量`x`的类型为`int`，位于地址`0x100`处，其十六进制值为`0x01234567`，地址范围`0x100`\~`0x103`的字节顺序依赖于机器的类型。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cvnjkn45iotughjuiorw.PNG)

大多数Intel兼容机都只用小端模式，另一方面，IBM和Oracle的大多数机器则是按大端模式操作。许多比较新的微处理器是**双端法（bi-endian）**，也就是说可以把它们配置为大端或者小端的机器运行。然而实际情况是，一旦选择了特定操作系统，那么字节顺序也就固定下来。比如用于许多智能手机的ARM微处理器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统——Android和IOS——却只能运行于小端模式。

对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的，无论为哪种类型的机器所编译的程序都会得到同样的结果。但有时候字节顺序会成为问题。首先是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者相反时，接收程序会发现字里的字节成了反序的。为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以确保发送方机器将它的内部表示转换成了网络标准，而接收方机器则将网络标准转换为它的内部表示。

第二种情况是当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在检查机器级程序时。作为一个示例，从某个文件摘出了由**反汇编器（disassembler）**生成的代码：

```
4004d3: 01 05 43 0b 20 00			add %eax,0x200b43(%rip)
```

十六进制字节串`01 05 43 0b 20 00`是一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由`0x200b43`加上当前程序计数器的值得到。这个序列的最后4个字节：`43 0b 20 00`即为地址`0x200b43`的相反顺序的显示。

第三种情况是当编写规避正常的类型的程序时。在C语言中，可以通过使用**强制类型转换（cast）**或**联合（union）**来允许一种数据类型引用另一种数据类型。大多数应用编程都强烈不推荐这种编码技巧，但是它们对系统级编程来说非常有用，甚至是必须的。如图展示了一段C代码，其使用强制类型转换来访问和打印不同程序对象的字节表示。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cvjio4tjio5ty2jgrwuiofeq.PNG)

在几种不同的机器上运行代码，得到下图所示的结果。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/grjw8i5j23uiogrnfuy.PNG)

参数12345的十六进制表示为0x00003039，对于`int`类型的数据，除了字节顺序以外，我们在所有机器上都得到相同的结果。其中我们可以看到在Linux 32，Windows，Linux64上，最低有效字节值先输出，说明它们是小端法机器，而Sun是大端法机器。同样地，`float`数据的字节除了字节顺序以外也都是相同的。然而指针值却是完全不同的，不同的机器/操作系统使用不同的存储分配规则。一个值得注意的特性是Linux 32，Windows，Sun的机器使用4字节地址，而Linux64使用8字节地址。



## 表示字符串

C语言中字符串被编码为一个以null字符（`'\0'`）结尾的字符数组，每个字符都由某个标准编码表示，最常见的是ASCII字符码。字符串`"12345"`的字节表示为`31 32 33 34 35 00`。



## 表示代码

考虑下面的C函数：

```C
int sum(int x, int y) {
    return x + y
}
```

当我们在机器上编译时，生成如下字节表示的机器代码：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/docpsvjkion2tji4gnhefd.PNG)

我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方式。即使是完全一样的程序，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。



## 布尔代数简介

略



## C语言的位运算

略



## C语言的逻辑运算

略



## C语言的移位运算

左移将x向左移动k位，丢弃最高的k位，并在右端补k个0。右移类似，逻辑右移在左端补k个0，而算术右移在左端补k个最高有效位的值。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vcnjkswdfnguiohj245ouity.PNG)

C语言标准并没有明确定义有符号数应该使用哪种类型的右移——算术右移和逻辑右移都可以，因此任何假设一种右移形式的代码都可能遇到可移植性问题。但实际上几乎所有的编译器和及其组合都对有符号数使用算术右移，而对于无符号数则必须是逻辑右移。





# 整数表示

## 整型数据类型

C语言支持多种整型数据类型来表示有限范围的整数，这些类型如图所示。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/jcizxvklonoui5rjio24tty.PNG)

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vcjkiohjnmtgioj376y.PNG)



## 无符号数的编码

略



## 补码编码

最常见的有符号数的计算机表示方式是**补码（two’s-complement）**形式。补码编码的定义中，<u>最高有效位 $x_{w-1}$ 也称为符号位，其权重为 $-2^{w-1}$ </u>。

如图展示了针对不同字长的几个重要数字的位模式和数值。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vncjinuioh25yuoi25y.PNG)

关于这些数字有几点值得注意：第一，补码的范围是不对称的， $TMin$ 没有与之对应的整数，这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误；第二，-1和 $UMax$ 有同样的位表示——一个全1的串，数值0在两种表示中都是全0的串。

C语言标准并没有要求用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的。程序员如果希望代码具有最大可移植性，能够在所有可能的机器上运行，那么我们不应该假设任何可表示的数值范围，也不应该假设有符号数会使用何种特殊的表示方式。



## C语言的有符号数和无符号数

C语言允许在各种不同的数字数据类型之间做强制转换，对于大多数C语言的实现中，<u>强制类型转换的结果保持位值不变，而只改变解释这些位的方式</u>。

当C语言执行一个运算时，<u>如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的</u>。因此当比较`-1<0U`时，因为第二个运算数是无符号的，第一个运算数就会被隐式地转换为无符号数，因此表达式等价于`4294967295U<0U`，返回0。



## 扩展一个数字的位表示

要将一个无符号数转换为一个更大的数据类型，只需要简单地在表示的开头添加0。这种运算称为**零扩展（zero extension）**。

要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展（sign extension）**，在表示中添加最高有效位的值。



## 截断数字

如果我们减少表示一个数字的位数，例如：

```c
int x = 53191;
short sx = (short) x    // -12345
int y = sx              // -12345
```

第2行将`x`强制类型转换为`short`，即是将32位的`int`的前16位截断，剩余的后16位是-12345的补码表示；第3行再将它强制类型转换为`int`，符号扩展把高16位设置为1，所以依然是-12345的32位补码表示。

当将一个 $w$ 位的数截断为一个 $k$ 位数字时会丢弃高 $w-k$ 位，可能会改变它的值——这是溢出的一种形式。





# 整数运算

## 无符号加法

两个 $w$ 位非负整数相加时，结果可能需要 $w+1$ 位。当完整的整数结果不能存放到数据类型的字长限制中时，就发生了算术运算**溢出**。当执行C程序时，<u>不会将溢出作为错误而发出信号，而是直接截断溢出的位</u>，这时的模数加法形成了**阿贝尔群（Abelian group）**。



## 补码加法

两个 $w$ 位补码整数相加时，同样将结果截断到 $w$ 位，结果却可能出现两种溢出：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vjdsfionjk5tiowgjrio.PNG)



## 补码的非

计算补码非有两种方法：

1. 对每一位求补，最后对结果加1
2. 对最右边的1的左边的所有位取反



## 无符号乘法

同样截断到 $w$ 位。



## 补码乘法

略



## 乘以常数

相比于加法、减法、位级运算和移位只需要1个时钟周期，整数乘法需要3个或者更多的时钟周期。因此编译器使用了一项重要的优化，即用移位和加法运算来代替程序常数因子的乘法。例如，假设一个程序包含表达式`x * 14`，利用 $14=2^3+2^2+2$，编译器会将乘法重写为`(x<<3)+(x<<2)+(x<<1)`，无论`x`是无符号还是补码，甚至当程序会导致溢出时，两个计算都会得到一样的结果。



## 除以2的幂

整数除法比整数乘法更慢，需要30个或者更多的时钟周期。除以2的幂也可以用移位运算来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。





# 浮点数

## 二进制小数

形如
$$
b_mb_{m-1}\cdots b_1b_0.b_{-1}b_{-2}\cdots b_{-n-1}b_{-n}
$$
的二进制数定义为
$$
b=\sum_{i=-n}^m 2^i\times b_i
$$
例如 $101.11_2$ 表示为 $5\frac{3}{4}$。

假如仅考虑有限长度的编码，小数的二进制表示法只能表示那些能够被写成 $x\times 2^y$ 的数，其它的值只能够被近似地表示。



## IEEE浮点表示

IEEE浮点标准用 $V=(-1)^s\times M\times 2^E$ 的形式来表示一个数：

+ <u>符号（sign）</u> $s$ 决定这个数是正数（ $s=0$ ）还是负数（ $s=1$ ）
+ <u>尾数（significand）</u> $M$ 是一个二进制小数，其范围是 $1\sim 2-\varepsilon$，或者是 $0 \sim 1-\varepsilon$ 
+ <u>阶码（exponent）</u> $E$ 的作用是对浮点数加权，这个权重是2的E次幂

将浮点数的位表示划分为三个字段，分别对这些值进行编码，如图展示了两种最常见的格式：单精度浮点数格式中，`s`，`exp`，`frac`字段分别为1位，8位和23位；双精度浮点数格式中，`s`，`exp`，`frac`字段分别为1位，11位和52位。

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vcxnlojio35jtoiwfsdfqe.PNG)

根据`exp`的值可以将被编码的值分成三种情况：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/vcmiop0o24iksdfijg.PNG)

1. <u>规格化的值</u> 这种情况中，阶码的值被解释为 $E=e-Bias$，其中 $e$ 是阶码字段`exp`表示的无符号数， $Bias$ 对单精度为127，双精度为1023。由此产生指数的取值范围对于单精度是-126\~127，双精度是-1022\~1023。

   小数字段`frac`被解释为小数值 $f$，其二进制表示为 $0.f_{n-1}\cdots f_1f_0$，尾数定义为 $M=1+f=1.f_{n-1}\cdots f_1f_0$ 

2. <u>非规格化的值</u> 这种情况中，阶码值是-126或-1022，尾数值是 $M=f$ 

   非规格化数有两个用途：表示数值0；表示非常接近0.0的数。

3. <u>特殊值</u> 无穷表示溢出的结果；NaN（Not a Number）表示不是实数或无穷的结果，如复数、 $\infty-\infty$ 



## 数字示例

如图展示了6位浮点格式能够表示的数值，可以观察到，可表示的数并不是均匀分布的——越靠近原点它们越稠密：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/czvnuijnio4t2njmsgjkdvf.PNG)

如图展示了8位浮点格式的示例，可以观察到最大非规格化数和最小规格化数之间的平滑转变：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cvj9oi5jyuijgwrufsvg.PNG)

此外，上图中的值随着位表示同时增大，因此浮点数也可以轻松地排序。

如图展示了一些重要的单精度和双精度浮点数的表示和数字值：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cvnuijfngiju42joiutj.PNG)



## 舍入

由于表示方法限制了浮点数的范围和精度，所以浮点运算只能近似地表示实数运算。**舍入（rounding）**就是对于值 $x$ 找到最接近的可以用浮点表示的值 $x'$。IEEE浮点格式定义了四种不同的舍入方式，其中向偶数舍入（也称为向最接近的值舍入）是默认的方式：

![](https://raw.githubusercontent.com/xyxxxxx/image/master/cvhuiwrhnuiy25jqef.PNG)

其它三种方式产生实际值的确界，有一些数学上的应用。



## 浮点运算

IEEE标准指定了一个简单的规则来确定算术运算的结果：将浮点数 $x$ 和 $y$ 看作实数，某个运算 $\odot$ 定义在实数上，计算将产生 $Round(x\odot y)$，这是对实际运算的精确结果进行舍入后的结果。该规则独立于任何具体的硬件或软件实现。当参数中有一个是特殊值时，IEEE标准定义了一些使之更合理的规则，例如定义 $1/-0$ 产生 $-\infty$， $1/+0$ 产生 $+\infty$。

$x+^{\rm f}y$ 定义为 $Round(x+y)$，这个运算是封闭的（由于溢出可能得到无穷值），可交换的，但是不可结合的，例如`(3.14+1e10)-1e10`得到0.0（因为舍入），`3.14+(1e10-1e10)`得到3.14。

浮点加法不具有结合性，因此缺少了群的最重要属性。对于科学计算程序员而言，这具有重要的含义。例如给定如下代码片段：

```c
x = a + b + c;
y = b + c + d;
```

编译器可能试图通过产生下列代码来节省一个浮点加法：

```c
t = b + c;
x = a + t;
y = t + d;
```

然而这个计算由于改变了加法运算的结合方式，可能会产生与原始值不同的值。

浮点加法满足单调性属性：如果 $a\ge b$，那么对于任何 $a$ 、 $b$ 以及 $x$ 的值（除了NaN），都有 $x+a \ge x+b$。无符号和补码加法不具有这个属性。

$x*^{\rm f}y$ 定义为 $Round(x\times y)$，这个运算同样是封闭的（由于溢出可能得到无穷值），可交换的，不可结合的，例如单精度浮点情况下，`(1e20*1e20)*1e-20`得到 $+\infty$，而`1e20*(1e20*1e-20)`得到`1e20`。另外，浮点乘法对加法不具有分配性，例如单精度浮点情况下，`1e20*(1e20-1e20)`得到0.0，``1e20*1e20-1e20*1e20``得到NaN。

浮点乘法满足单调性属性：对于任何 $a$ 、 $b$ 、 $c$ 的值（除了NaN），如果 $a\ge b,c\ge 0$， $a*^{\rm f}c\ge b*^{\rm f}c$ ；如果 $a\ge b,c\le 0$， $a*^{\rm f}c\le b*^{\rm f}c$。

对于科学计算程序员和编译器编写者来说，缺乏结合性和分配性是很严重的问题。即使是在三维空间中确定两条线是否相交这样的任务也可能成为一个很大的挑战。



## C语言的浮点数

C语言提供的两种不同的浮点数据类型`float`和`double`，在支持IEEE浮点格式的机器上分别对应于单精度和双精度浮点，并且使用向偶数舍入的舍入方式。但是由于C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式，或者得到特殊值。

当在`int`、`float`和`double`格式之间进行强制类型转换时，程序改变数值和位模式的原则如下：

+ `int` -> `float`，数字不会溢出，但是可能被舍入
+ `int, float` -> `double`，能够保留精确的数值
+ `double` -> `float`，可能舍入，或者溢出为 $+\infty$ 或 $-\infty$ 
+ `float, double` -> `int`，值将会向零舍入，也可能溢出，C语言标准没有对这种情况指定固定的结果



